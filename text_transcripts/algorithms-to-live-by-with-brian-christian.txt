Transcription: when you were deciding who to marry you are using an algorithm the same as true when you were looking for a parking space playing a game of poker or deciding whether or not to organize your closet algorithms to live by is a book about the computer science of human decisions it offers strategies for how to think through everyday life like a computer scientist Brian Christian has a background in computer science and philosophy and it's an author of algorithms to live by he joins the show to explain how the same algorithms and data structures that we use for our computer programs can be applied to the real world I really enjoyed this episode I enjoyed Brian's book algorithms to live by and I think you will enjoy them as well
so you've got a bacon delivery service and you need to notify your customers when their bacon has arrived at their doorstep twilio helps you make sure your customers get the bacon while it's hot twilio's programmable API let you build SMS or voice alert easily in the programming language of your choice all in under 5 minutes with only a few lines of code now your customers get a text or a call the instant their bacon is ready if your customers want to see the bacon frying on a hot pan twilio has video API eyes and SD case for the platforms that you know and love learn more It Go. Twilio.com podcast and get an additional $10 when you sign up an upgrade your account that's go. Twilio.com podcast you will only pay for what you use and it cost less than a penny to send a text get started at go
twilio.com podcast get your bacon delivery service cooking with twilio API for Voice SMS and video
 Brian Christian is a co-author of algorithms to live by Brian welcome to software engineering daily thanks so much for having me to live by is about the computer science of human decisions what does that mean the basic premise of the book is is pretty straightforward articulate you know there's there's a class of problems that all of us face in everyday life whether it's you know choosing the apartment we want to live in or deciding where to go out for dinner or managing are messy offices or scheduling our time and we think of these as in some sense intrinsically and uniquely human problems and the message of the book is in fact they're not they correspond rather profound lead to a set of some of the fundamental problems in computer science and so this gives us a real opportunity to learn something about how to make better decisions in our own lives
 I was thinking about the the structural properties of the problems that we face and what the ideal Optimal Solutions for those problems look like and that you discussed in the book are things that were designed for computer systems how closely does our everyday life resemble a computer system yeah I mean I think they're there are a surprising number of ways in which these these formal problems can a rear their head in everyday life and so one of the examples that we make in the book is you know if you imagine that you are looking to you know rent an apartment say or buy a house let's just go to the example of renting so you go to a you know you see a listing on Craigslist you show up and you like the place pretty well and you have to decide you do you take this apartment or do you walk away and consider your options for another week and explore other open houses but
 chasing but in doing so you lose the opportunity to go back and so I hear you're in this type of a problem that's known as an optimal stopping problem so you have to make a decision at each step along the way do I take the option in front of me in which case I kind of forsake all possible future options that could be better I'll never know what else might have been out there or do I walk away to keep exploring what's out there but in so doing I may lose the opportunity in front of me and so I think this is kind of a classic human dilemma some it plays out not only in apartment hunting but you know for driving down the street can we see a parking space at we have to ask ourselves this question of do I take the space right here or do I keep going in and take the gamble that there might be a better space ahead and you know many people have argued that this is also kind of a rough description of of dating right somewhere in a relationship
 but at some point you have to make a decision about do you commit to this person and not know who else might have been out there or do you break up in order to meet other people but you may forfeit the ability to change your mind and die and go back if you feel you made a mistake and so Explorer versus exploit in the book this this specifically is an area called optimal stopping this is optimal stopping right to this structure of you're presented with a sequence of opportunities and in each step in the sequence you either stop on the option in front of you or you continue on and so you're here at yours a case where by identifying you know the underlying cognitive or computational structure to the problem it gives us a a way of making sense of it in a way of sort of recognizing the type of situation that we're in
 and Steve the classic version of the optimal stopping problem is called the secretary problem and it's it's a similar structure you know you have your hiring a secretary and X number of candidates show up in a random order in you interview them one at a time at East point in time you can either higher the person or dismiss them and there is this wonderfully simple optimal solution which says that if you want to get the best chance of hiring the very best candidate don't commit to anyone for the first 37% of the kennedy pool and then immediately hire the next person who's better than everyone you saw in the first 37% and so you can you can translate this principle for instance directly into the apartment hunt context so if you've given yourself a month to find an apartment and you want to give yourself the best chance of finding the very best apartment then you should stay
 the first 37% of your search so in this case 11 days if you've given yourself a month non-committal e exploring your options and then after that initial 11 days be prepared to immediately jump on the first thing you see that's better than what you saw on those first 11 days framing then life actually presence is with cuz very often in this type of scenario we allocate 11 days and work we decide that after 37% of that time working to do like you said the next option that we get that's better than all the previous options will go with but in real life during the first portion of those 11 days we might say I don't want to live in this neighborhood at all I don't want to live in this place at all there are so many edge cases that occur in in real life how do you contrast that rigid algorithmic way of living
 life versus the richness in the complexity of the decisions of everyday life as they actually appear so I mean one of the things that comes up in the book in every chapter we are not having having broken down the essential mathematical structure of the problem and looked at the the things that characterize the Optimal Solutions to those problems there is of course this irresistible question which is is that what people actually do when they are put in that situation and in most cases the answer is a resounding no so for example if you put undergraduate Santa Ana psychology study into it into a lab environment and you get them to do these optimal stopping type problems do they inherently time intuitively implement the 37% rule not the answer is no they they appear to do something pretty close to it but they consistently
 stop earlier than they should they appear to implement for example something roughly roughly equivalent to a 31% rule and so you can you can offer a number of explanations for this discrepancy and some people have argued you know well humans are just kind of risk-averse they would rather take a sub-optimal thing then you know risk the chance of being empty handed and there's there's one particular interpretation of the data that I find particularly interesting which is
 Summit have a look at that at the raw data from this particular experiment and they found that human judgment matches up really closely to the optimal strategy if you are assessing let's say a 1% utility penalty for each additional option considered and they they found well this is weird because we there was no such penalties so why were people acting as though there was and I think a fair answer to that is well there they're human they're real people doing a fairly boring and repetitive psychology experiment and they would just as soon be be done with that rather than prolonging the experiment and so you know we might collaborator Tom and I talked to some of the psychologist that it would have done these experiments and they say yeah you know it's it's it's understandable that the subject just get kind of
 bored and restless but we don't have a way to rigorously model that insecure is a case where you know it whenever there's a discrepancy between the formal prediction and actual human behavior you have an opportunity to ask this question of who's wrong or the people wrong or are the models wrong and in many cases we actually end up coming down on the side of human intuition and saying it seems like what's happening is people are implementing a sensible solution to a subtler version of the problems than the one that the experimenter thought they were solving certainly okay so let's talk about some of the other fundamental questions that you look at in algorithms to live by one is the trade-off between space and time this is a classical computer science trade-off exchange computer scientists understand this trade-off how does the trade-off between space and time manifest in our everyday
 world I think the most clear example would be something like organization right like your home office organization and so forth now ideally you know you listening about this I mean in some ways there's there's an even earlier trade-off that you have to make which is between effectively between time and time so you know when in a home organization contacts we talk about what's called the search sort trade-off so this is something that comes up in in computer science contacts related to you know database management for example this also relates to the space time. Also you know if your if your database administrator you have this question of what what indexes do you implement in your database you know do
 put in an index for every possible column in every possible table well that's kind of consume extra space because you're going to store those indexes it's also going to consume extra time on every insert and delete cuz you're now also going to have to update the index but as results in the upside of that trade-off is that it becomes much easier to find things and so the way that a computer scientist would approach a problem like this is to say well you know is it is it going to take us more time to create this index then we are going to save down the road by having the index and so this is a principle that we raised in the context of you know whether or not to alphabetize your bookshelf for example you know that there is this question of is it is it going to take you more time to get organized
 you will save by being organized and in many in many domestic contacts we argue that that that is in fact exactly what happens and so I think counter-intuitively to a lot of people in a week we think of computers as the paragons of you know orderliness but in fact if you look at how cashing schemes work computers are are much messier than then they let on and moreover I think computer science gives us surprisingly the framework in the language with which to articulate the the pro Mist argument that sometimes sometimes mess is not just the easy choice but it is in fact the optimal choice
 engineering daily has 20,000 Engineers listening Monday through Friday if you are hiring or if you have a product that you would like to get into the hands of Engineers send me an email Jeff at software engineering daily.com this podcast is sustained by the advertisers and if you would like to become one or even if you're just curious and you want to learn more send me an email Jeff at software engineering daily.com thanks for listening
 in computer science we're talking about data structures along with are algorithms and many times the data structure lets us cheat our way out of an algorithm that might have been seemingly impossible like I think of the hashmap is the classic example of this Psych hashmap is just like cheating compared to all of the things that you can do with out or what you're capable of doing without a hashmap but there's not really a wider more I think about it baby you you can taste me different but when I think about the hashmap I don't think there's like a logical construct in the real world that's the maps to a hashmap so are their data structures to live by or or are you know toad is is algorithms to live by that were limited to in the real world
 yeah that's a great question and I was I was reminded of when Tom and I were doing some of the interviews for this book we went we went to Harvard and we talked with Michael Madsen Locker who is that an expert on hashing algorithms and he he insisted on taking the interview outside of his office because it was full of this chaotic you know mess of papers that he did not want to disturb in any way lest it upset his you know highly precise cashing system or hashing system I should say in which you know he just knew where every object would be found if it were there so I think that's one of the irony is of human life which is the you know that the thing that most mimics this kind of order of one hash look up system is
 is chaos but as long as you as long as you remember where everything is in that chaos then you're fine of course if you forget then you have to look through it at random and in your now you're living in the order then world but you know do your question of how data structures work I mean I think you know if you if you think about something like a bookshelf there's there's this open question of to what do near what data structure best describes a bookshelf you know an alphabetize bookshelf is a little bit like you know a binary tree because if you're looking for a book that you know an M or an N you know to look in the middle and then you know you know to look to the left or right of that and you can kind of
 Intuit your way towards the item and it it's it's not exactly clear how that maps to a data structure where do you have you have a basic idea of where that where the index is the other thing that we talked about in the context of bookshelf organization is your typically if you want to if you want to make some optimality argument about a particular algorithm your your minimizing you know the total number of operations but there's there's not always a clear separation between the types of operations that you're talking about so for example if I'm trying to organize my bookshelf I'm trading off the the amount of time it will take me to kind of insertion sort these books into place versus the amount of effort it will take me to scan the spines for something I'm looking for later but there's a fundamental disconnect which is that I'm I'm sorting with my hands which are orders of magnitude slower than my
 eyes and I'm I'm searching with my eyes so there's a little bit of an apples to oranges thing that's happening there another one of the interviews that Tom and I did was David Carter at MIT who talks about data structures and and we had a long conversation about you know exactly to what degree do you know human physical objects schemes map to some of the canonical data structures in computer science in night you know it's kind of an interesting open question so one of the algorithms I think of as a just a brilliant merger of algorithms and data structures is dijkstra's algorithm which is the funeral uses priority queues in a very creative way and you know obviously has it is it's an efficient way of finding the I think what is it the shortest path between anode
 snowed in all destination nodes dijkstra's algorithm seem like this just like how would you come up with dijkstra's algorithm when you were doing research for this book and you're looking at the different a computer scientist to solve these really hard problems you talk about Dexter some in the book but was there something unique about Dykstra was like I said he was very literary he wrote a lot I know maybe you could give some information about the extra and how it compares to other how we compared to other computer scientists and what your thoughts on dijkstra's algorithm are yeah I mean dijkstra's algorithm is very near and dear to my heart because one of my early computer science projects when I was an undergrad was I looked at them I looked at this data structure for language called wordnet which someone sees me someone took the trouble to
 semantically categorize all the words in English you know into this tree structure of you know a collie is a dog is a mammal is an animal is a physical thing or something like that and so it occurred to me that you could use dijkstra's algorithm to Traverse wordnet and find some numerical representation of the similarities between Pairs of words right so how many how many hops is dog from frisbee or something like this and this put the idea in my head that you could characterize human speech by looking at you know that the distribution of the word net distance between neighboring words and so I ended up doing a research project where I took the
 Shakespeare assume control group of normal you know just regular human beings versus Shakespeare vs the speech of skitzofrenix and I within each Corpus I calculated you know various metrics using dijkstra's algorithm to connect the different adjacent pairs of words in Word in it and it was able to find statistically significant differences between all three sets of data so I remember it vividly that my computer spent you know the better part of the summer just grinding away Computing dijkstra's shortest path on nioh tens of thousands of words
 midnight I think
 you know there's
 there's no doubt that diaper is one of the
 Brilliant Minds of even among you know some of the canonical computer scientist interview with Leslie Lamport a couple years ago and he referred to dijkstra as being really a formative influence in his own work and when I think about other people come up with very creative algorithms that are solutions too much as he's Brilliant Solutions of shipper creative to really really hard important problems less than Port certainly falls into that category as well regarding what you said about Dexter like that that that that algorithm there was a show I did recently about Netflix Netflix movie recommendation algorithms how it looks these days and they build maps of little things that look like like like maps of
 Vina locations but it's movies and they they they run dijkstra's on movies to find you know the nearest neighbors or the the things that would be Geographic not geographically but you know if it will geographically in some weird space so it is it is not just like this this traveling salesman in the sense of a physical in a physical location type of algorithm solution it's it's it's applicable to this very rich set of a problems ship some and I just want to I just want to add on to that then the other thing that comes to my mind when I think about Dykstra is the famous go to considered harmful you know that he was one of the people thinking about the structure of programming itself in this this makes me think of
 we're actually wanted to include a chapter in the book at it ended up not making it into the final printing but we had a section that looked at data structures and you know depth-first search vs. breadth first search and the the ways in which you could consider you know the the execution of the program itself as being kind of a traversal basically depth-first you know traversal through the code and I think there's there's really something you know
 critical about these moments in the history of computer science where you know the the move towards structured programming the move towards object-oriented programming the move towards test-driven development and so forth where people have kind of stepped back and said you know okay we were sort of bumping up into the maximum complexity of the you know the programs that we can write relative to the amount of complexity that the human mind can fit into it it's working memory at a time you know how can we how can we try to be more disciplined about the way that were writing code such that it you know enables us to write ever more complex systems and still feel like we're in some sort of control so I associate that
 in large part with Dykstra also and I think that's that's something that has influenced my thinking in terms of I you know by by analogy I think of myself as being kind of like a a CPU that's executing this series of instructions and you know go to considered harmful it is kind of it's something that I think about it in terms of you know if I'm if I'm interrupted by a task do I then resume the previous task or do I just end up going off on some tangent so I try to apply the same discipline to my own you know time management that one would to think about the structure of the program so that definitely is the other sort of interesting dimension of dijkstra's work that I find myself thinking about again and again you explore poker from a variety of angles in algorithms to live by
 what is useful about poker as a mechanism to look at algorithms through game theoretically there's a couple interesting things about poker in it as you say it comes up in a few different points in the book and one of the places that it comes up is our chapter on sorting and the reason we get into poker there there's a there's a whole branch of Cs Theory within sorting on what's called minimum comparison sorting so how you know if you've got 10 10 items I mean the classic wave thing about it is you have a 12
 items of unknown wait you know they're they're all the same size they have different way different amounts and you have a little scale and you want to arrange these items from lightest to heaviest what is the absolute fewest number of times that you can use that scale in order to confidently sort all of the all these objects and Sophie the passionate listener is encouraged to check out Donald knuth Tome the art of computer programming I think it's volume 3 is entirely dedicated to sorting and searching Theory what we look at in the book is are there cases where in affect nature Implement something that's close to a minimum comparison sort and so the world of what's called a heads-up cash games in poker offers us once I
 case study and so heads up poker is just one-on-one and cash game poker means we're not we're not playing for some abstract you know chips that map in assertive non 121 wait to money we're just playing for actual money so when I when I wager $10,000 that's 10,000 actual dollars so actually a former classmate of mine in the computer science program at Brown Isaac Haxton has gone on to be one of the consensus you know top five heads up cash game poker players in the world and so I spent a bunch of time talking to him about what is that like what's the thought process like and he said something really interesting to me that's that's stuck with me which was in many ways the
 critical skill the single most important skill of any poker player is not being good at poker it is knowing exactly how good at poker you are if you are the third best player in the world but you insist on playing the first and second best player in the world you will go bankrupt and you will not have a career and so that for me was just a completely fascinating insight and it leads one to wonder why top poker players agree to play each other because there's actually a very high degree of consensus within the poker community of what the what the stack rank of the top 20 let's say people are and in fact this is what you see you often see you know that the number one player issues a challenge to the number to guy who declines he was a challenge to the
 03 guy who declines and so on and so forth and there's actually this funny stasis that you see at the top levels of the game and so whenever two people agree to play with you know heads up cash poker it can only be because they both feel that they are the superior player and so this I think corresponds really nicely to some of this theory that exist in the in the world of sorting on you know what what is the absolute fewest number of head-to-head comparisons that are necessary to produce a stable hierarchy and we also look at this question in in primatology there you know if you look at dominance hierarchies in chimpanzees and mechanics and so forth you find that at in there people who have done done work on this you find
 that nature appears to implement something close to an optimal in a minimum comparison to work because in these cases you know that the comparator operation is is simply that the the primates literally come to physical blows and so you know it's it's in the interests of the entire tribe that that happens the minimum number of times and that a stable hierarchy results and so interesting to try to bridge the gap between this seemingly Arcane Theory and the natural world around us an in and try to recognize cases where in a kick into a sorting algorithm this taking place weather we we recognize it immediately or not I used to play against Isaac Haxton and number of times and he's
 okay that guy's credit Pearson player it is cuz you know as heads up cash games work really catching on in the online world you know there was a lot of six player games and there's some 9 player games around that time win-win heads up was really catch you on it was funny because the people who were really dominant at heads up when they would come and sit down at 6 player games they would have such an influence on the table it was like the gravity in the table would shift towards that player whether it was a real or kind of a manufacturer defect like the the dead dominance hierarchy they're talking about it quite interesting effect and as a poker player I remember
 feeling somewhat ashamed that my my Approach the game feel very out algorithmic like I had just read a bunch of books and I was reading stuff online and I was basically copying what other people did but in reading your book I'm staying by is like poker is just algorithmic like it you you should have an algorithm if you don't have an algorithm you should you know you should probably figure one out you don't want to be. They say it's actually not a game of an improvisation there is some elements of improvisation but in a perfect world you would have every single point of the decision tree mapped out because there is a finite number of decisions that you can make in a given hand it's like a it's like you have a state machine that gets generated after every hand and you should be able to Traverse that that state machine another interesting thing you said there are the direction players who have come up through the ranks this guy is solder comes to mind
 how much do the ranks doing things that are totally unconventional and they're so outside the bounds of what the typical players are doing like they'll do things like over bet the pot or you know you know men raise every every open in a heads up gaming and sometimes it throws off the The Experience players I don't think this happens as much anymore cuz the heads up heads up no limit has been explored so thoroughly but it is interesting that that the algorithms that the top players developer often a product of the previous algorithm said come before then because you're always just developing an algorithm that is simply a counter strategy to have the other algorithms that are pre-existent yeah and you would expect I mean at least in a purely theoretical since you would expect the system to drift towards some Nash equilibrium where there is no longer any room for anyone
 to elevate strategically it's just reached some kind of static point where you know everyone's strategy is as Optimum as it can get given the ecosystem of other strategies that exist and this is actually something of an open question within game theory is you know everyone everyone knows these famous theorems that you know II Nash equilibrium always exists in a zero-sum game but computer scientists have been able to really push Game Theory into a new set of questions and so for example in the in our chapter in Game Theory we talk to Christos papadimitriou who's one of the people one of the theoretical computer scientist that's asking a fresh set of questions about Nash equilibrium which is okay and we have this famous there on that says they all
 exist but I said computer scientist I don't even send since it's it's unsatisfying to Simply know that it's out there you know to tell me how to find it what what is the complexity associated with the computational effort required let's say to find where the Nash equilibria are and the sobering result is that it turns out than in most cases
 finding Nash equilibria is effectively intractable and so it it throws the means to me as it is a fascinating development because it throws the the utility of Nash equilibrium as a concept kind of out the window which is to say you know if if this stable Point exist but none of the players in the game can find it well then how useful is that equilibrium as a predictor of the actual behavior of the players in the game not to mention people told all the time and that throws off the ability to say like okay how close are we reaching how close are we as a pair of heads up players to reach a Nash equilibrium beat up somebody's tilting that kind of throws things off yeah right and it ended in some sense that the exact
 sense of genuine tilt is kind of a critical part of what keeps the game interesting because event that makes it possible to Bluff that one is tilting or two you know that if someone appears to be till then you have to ask yourself whether it's for real or not or what you want to do about it
 when I'm choosing the tools for my side projects the first thing that I look for is ease-of-use that's why I love mongodb it is the most popular non-relational database and it is super easy to use at the beginning of a project I often don't know the shape of my objects and Mongo makes it easy to evolve the database schema as I like overtime overtime as my project gets popular I'm going to need to scale and thankfully mongodb has built-in horizontal scalability but configuration and database maintenance aren't really what I want to spend my time on thankfully mongodb Atlas was released in 2016 mongodb Atlas is the easiest way to get access to mongodb without having to run the database yourself you pay only for what you use for small projects all the way up to large production deployments to try mongodb Atlas today go to mongodb. Com
 daily get a free $25 in credit Atlas is the only hosted mongodb service built by the engineers behind the database the company mongodb with Atlas you get into end encryption you get VPC peering you get access to the latest releases and for a limited time you can go to mongodb. Com SE daily and get that $25 in credit and get started with mongodb Atlas thanks to mongodb for being a new sponsor of software engineering daily and thanks for being the database behind a lot of my favorite side projects in the past really happy to have mongodb as a new sponsor of software engineering daily
 you write a little bit about the flash crash and the 2008 crisis and I think of these as interesting examples of herd mentality in the well the cross-section of herd mentality and gambling what are the algorithmic lessons and the lessons about human nature that you take away from the market turmoil of you know the two mm on a 2007 through 2020 2009 or whenever that. Of time you're looking at is yeah and then the flash crash was like 2010 I think
 yeah I mean I think the The Narrative that always seems to get traded out in the Press after something like this has the character of figuring out who was the bad actor or who who's to blame who made the mistake whether through mal-intent or just in company and the story that you get from looking at these sorts of things in in Game Theory Reddit terms the framework that I think is the most interesting is comes from the early 90s in it it's this idea of informational Cascades and the basic idea of an informational Cascade so I'll give you the kind of the toy example that they use in the in the literature which is what say you've got to two urns at and one one has mostly blue balls in it and one has mostly red balls in it
 and there's there's a bunch of people in it in a line and each person gets to go up to the urn at which could which could be one of these two different someone goes up to it and they pull a ball out at random they get to observe that ball but no one else does and then they have to say whether they think that this was the mostly writer and where the mostly blue urn and so that the critical thing here is that all of the other people get to know that person's guess but they don't get to know what that person actually saw
 is it this is a difference between it's called private information and public information so let's just say for the sake of argument that you know it's the two thirds blue and 1/3 red okay well that means that there's a a 1 and 9 chance that the first two people both so red balls even know the urn is mostly blue so that there's a 1 in 9 chance of that happening and if that happens then the third person goes up to the urn and let's say they pull out of blue ball but they say to themselves well both of the previous people gave the prediction that it was the return so even though I have private information that goes against that it's still rational to say that we're dealing with the with the red urn even though it's not a blue ball in my hand and so that person puts that blue ball back and they say okay I my prediction is still that it's the red urn
 it said the 4th person goes up and we have now created what's called an informational Cascade which is there's no amount of private information that's going to overcome the amount of public information so the fourth person goes up they draw Blue Ball but they still vote red because they have seen three previous people vote ride you know the 5th person the six person so on and so forth and so you can see what happens here which is there wasn't there's a 1 in 9 chance of setting off this chain reaction that results in basically infinite misinformation this is kind of like the emperor has no clothes type of thing where you say well he looks naked to me but everyone else seems to be saying that he's closed so I'm going to Discount my private information in the flash crash
 yeah and I think I think this offer is a sort of a game theoretical framework for bubbles in general which is you know let's say I'm I'm looking at buying a an asset or let's just say house right let's say I'm thinking about buying a house and its costs $1000000 and personally I don't think it's worth a million dollars but everyone else seems to think it's worth more than a million dollars or divorce so I believe it's based on their behavior in the market so I buy it because I think well as long as I can find someone else who believes it's worth that then it doesn't really matter what I think but I've made an error here which is that I've I have assumed that other people's behavior is indicative of their beliefs even though my behavior is not indicative of my belief
 and so this is a case where he had this is how a bubble bubbles form basically and the the sobering story that you get by you know looking at the literature here is that you know I sent as I said it beginning we we always want to know who was the bad actor who made the mistake who was acting in bad faith or irrationally and in many cases the answer can be no one that I think this this offers a framework for Tom and I refer to in the book as the tragic rationality of bubbles that that it is there's there's no bad actor it may just be a cruel game it may just be that this is this is the rule that if you're in the middle of it whether you feel like you're in the middle of a bubble of mortgage-backed Securities or online advertising what is
 what's the algorithm for getting out of it or for identifying that you are in a bubble so that perhaps you can make some kind of contrarian bed and take advantage of it yeah I mean I think the the first thing is just recognizing the difference between belief and action so this is this is for me just a very key thing is being reluctant to make inferences about someone's actual beliefs based on what they do and also comes up in the context of oil drilling rights you sometimes get these weird bubbles where you know all these different oil companies are engaged in a bidding war over a tract of land that actually no one no one's private survey indicates is rich in oil but they infer from the bidding behavior of the other parties that the other people do think it's rich with
 and so they think well their studies might be better than ours so we'll get on it anyway and then you get it a similar cycle that just kind of spirals arbitrarily so I think the first thing is just recognizing that there is this gap between belief and action and in not being so quick to have to make that inferential leap I think that's part of it the other part of it is recognizing that if you are contrarian if you're that person that stubbornly doesn't buy the asset because you just don't think it's worth that much even though you're aware that there's kind of a general consensus that it is
 you are you are conferring a a social benefit you are there there is something in a way altruistic about that kind of behavior that the the person who refuses to go along with the herd will probably lose money on average or be wrong more on average than the people that take that information into account but on the other hand they may be part of part of the kind of the mechanism that keeps the system from going totally off the rails so 5 minutes or so left
 what are the problems for the difficulties in your everyday life that you find are difficult to solve algorithmically is there a class of problems that are characteristically not easy to apply an algorithm to yeah that's a great question I usually get the inverse of the question is it is most people who asked me about the book say give me an example of where you apply the stuff you're on my side like that your question is tell me where it fails to apply so I think one of the thorniest areas in human life is time management and your weed we have a chapter in the book that's on scheduling Theory and there are there are two basic problems in scheduling Theory one is that the typical metric that you would want to optimize if your if your
 doing scheduling is What's called the makes pan Which just refers to the total amount of times going to take you to do all the stuff and so it matches the most natural metric you don't know it's like how do I just finish everything as quickly as possible there's this little bit of a paradox in the in the Siri which is specifically in the area of single machine scheduling where are you just have one you have one machine one work or whatever that's going to do all the work and if you're if you're committed to doing all of the work then it actually doesn't matter what order you do it in because there's only one person to do it and then they have to do it all so it does not matter what order you do work in the mix band will be the same
 and so this is kind of an interesting anti results are negative result if you will and what that means is that the people who are interested in the field of single machine scheduling need to think about I need to think creatively about other metrics that they would want to optimize for in order to get some kind of optimal strategy to come out because otherwise you just get this answer that it doesn't matter what you do and some people have have come up with all sorts of different metrics you know if you want to you want to minimize the maximum lateness of Any Given job relative to its due date then there's this policy called earliest due date was just says do things in the order that they're due that's pretty intuitive but it turns out to be optimal if you want to minimize What's called the sum of completion times which is the total amount of time that every task is outstanding some Dover all the tasks
 then the optimum algorithm turns out to be this thing that's called spt shortest processing time which just means do the easiest things first and make your way up to the hardest things which again is intuitive but it's cool to know that there's an opthamology result there and the point that we make in the book is you know there's this idiom that says a man with one watch knows what time it is a man with two watches is never sure and I've always loved that quote and I think it's sort of rears its head here which is to say you know in single machine scheduling there there is not a single Optimum approach but a plethora and depending on how you want to frame the thing that you're that you're trying to do and so this is something that I think a lot of you know best seller self-help books on time management Miss is that you know if we can't even begin to talk about
 the right answer to the question of what should I do next until we have gone much farther an articulating exactly what the question is that we're asking and that's something for me that's been an interesting take away when I just think about my own life which is I think it's pretty it's pretty typical that we find ourselves in a situation of saying you know what do I do now what do I do next how do I plan my day and in many ways we're jumping the gun we are leapfrogging the essential first question which is what exactly am I trying to do am I trying to get the most stuff crossed off of my list as quickly as possible my trying to make sure that nothing goes too far over do you know what what exactly are my aims and I think personally I'm probably as guilty as anyone in terms of you know I don't always I don't always take
 except of articulating that to myself and so that it's been a nice reminder to to kind of take that first step so what are you working on these days I am now working on the beginnings of a new project which looks at the intersection of machine learning and ethics so I think we're at a really interesting moment in in another the progress both of technology and a policy we are increasingly turning over more and more aspects of the end of the functioning of society that is the news cycle yeah I mean the one that I had in my mind was on there was the investigative report that came out a couple weeks ago looking at the algorithms that predict prisoner recidivism
 and you know I sign a kind of a risk to reoffend that is now being used by by human judges as a way to figure out who should which prisoners should get parole in and who should be released and so forth and there was a bunch of systematic in this case I think racial bias that was found in the cell grow them and there's I think we're really at this interesting Crossroads where we have a lot of work to do to figure out how to translate the the values that we have is a society of quality In fairness and Justice and opportunity into algorithmic terms how do we how do we put what are the exact constraint that we want to put on this you know statistical system where this machine learning system in order to feel confident that the recommendations that it's spitting out
 conform to art art art set of values I think that's kind of an open research problem and it's also an open policy problem and we're we're sort of a hurdling into a world in which we need answers pretty quickly because this stuff is is getting deployed faster than we can figure out on you know I'm on the theory site exactly how to make sure it's doing what we want so that that to me is there a really really interesting area and I think there's a lot to be said about that cool well I look forward to seeing what fruits that work Bears I hope everybody checks out algorithms to live by so thanks, the show yeah thanks for having me Jeff it's been a pleasure
 software engineering daily is having our first ever meet up in San Francisco January 11th at galvanized if you live in the Bay Area and you listen to software engineering daily please come check it out I would love to meet you or to have some awesome speakers that Pete hunt who was one of the early members of the react JS team who is now the CEO of smite haseeb Qureshi who has been one of the most popular guests on software engineer daily preethi kasireddy who has written about her career transition from Venture Capital to software engineering via coding bootcamp each one of these speakers is going to give an awesome talk and I hope you can make it January 11th at Galvanize in San Francisco you can sign up on meetup.com you can also find the link on the software engineering Daily website software engineering daily.com I really hope to see you there
