Transcription: software engineering daily is sponsored by hired.com if you're looking for a job hired.com is the place to start I've used it personally and it is an excellent service software engineers and designers can get 5 interviews in a week with top companies go to hired.com software engineering daily for a $4,000 bonus upon accepting a job thank you hired.com
 Aaron Minsky is the head of quantitative research and Technology at Jane Street Capital is unique both because of its incredible success but also for it's almost exclusive use of Oak Hamill a functional programming language you're welcome to software engineering daily is good to be here it's worth me be correcting so I'm on the I'm the head of Technology no longer the head of quantitative research that part of the world is kind of moved I moved on and they're a lot more people there used to be when it when I had both of those titles okay well so Jane Street is a Trading Company how does the trading requirements how does that drive the technological requirements of the company
 so it drives in the number of ways I think it's obviously puts a lot of pressure on performance in that treating applications are dominated by large amount of data that you need to consume in real time in order Chuck's have any kind of response of system Market a few generating millions of transactions a second is not out of the realm of what you can get and you're pulling data from multiple different sources and that cost you both and building real-time systems that can respond to the text but also in collecting data getting accurate timestamps you understand when things happen to the past and being able to kind of bulk research where you go over and analyze large amounts of historical dated to understand things have happened in the past that all that requires good performance I think another thing that matters a lot is speed of implementation the ability to get new things done the markets are extremely Dynamic and so you constantly have to be coming up with new ideas
 meter reading quickly a good invariance for the world of shootings at everything you're doing is going away again you keep on doing the same job you're going forward you're going to see them get worse and worse and the only way to kind of build a good sustainable businesses to constantly be looking for new opportunities and looking to get better things are already doing and that puts a lot of pressure on dynamism on the glue to make new things quickly and is in some sense for a programmer terrifying to constantly automated trading because you are reading program which has access to your wallet and if you don't find that terrifying you're not thinking about it carefully enough make sure you're all terrible programmers before forgetful we make lots of mistakes and those mistakes end up in our code and this you have to put a lot of effort and Engineering into making sure
 that the software you build incorrectly carries out your intent and that both involves kind of ordinary Notions of software correctness that you see everywhere but also careful thinking about the way in which the software that your model of the world that you're building your software against whether that's really right and the ways in which the deviation between the model you expect in the world it's really there can cause you trouble two or three things performance correctness and dynamism and so before we get into how Oak Camo encapsulated those three traits well let's talk about some languages that do not encapsulate those what are some languages that exhibit the opposite of this correctness and Agility in performance
 short I think one of the things they can find it that it's not that languages did people use are strictly bad at everything I mean there are some languages are just really badly designed and kind of became popular because they happen to have good libraries and some Niche usually why they use languages are pretty good they're reasonable there but they're not good at all exactly the same to the things that other languages are which is in many ways a beautiful language is has give you programming model that's very close to the machine it gives you lots of control of rememory representation and less you right before Miko tonight in a very natural way
 but it's also very hard to reason about complicated C code because the compiler and the language that does very little to protect you from the kind of ordinary mistakes that we follow humans make fails on one side of the set of trade-offs and it the safety story is not so great and that makes the correct the store that we care about their programs harder to not impossible but I think significantly harder another lovely language different ways python so very user-friendly language language it was designed with a thick real attention towards how ordinary people think and one of the reasons why I think python is great you look at a piece of python code and it's almost pseudocode in many cases it's listening lovely about but it is
 freshly slow which makes it unsuitable for mostly job applications and I think the lack of type safety and I was like python means that for larger could basis it's very hard to use a and ending is hard in part because refactoring becomes very difficult and then I'm the type system of a especially about language like camel for reasons I guess what makes refactoring a lot easier than complete lack of a type system means that if you have some library that has many many clients and you want to change the semantics about Library it's very hard to find and correctly fix all the places where that is used and it makes certain kinds of Transformations very difficult example of this in the python Community is the Moon from Python 2.7 to Python 3 which has been around forever and there are a bunch of reasons sociological and other that people haven't fully made the flip two python3 but
 one of them is that you get very little help from the types of him in doing that move so there are some tools to help migrations but like the basic fact is the dynamically typed nature the language is makes this significantly harder to talking about oh camel why is o camel such an appealing language given the technological requirements of Jane Street
 so has a number of nice properties that that give it a really comfortable spot in a kind of set of trade-offs between all the different things we've been talking about so for example it is simultaneously safe meaning it's got its got the memory safety and lots of good supporting the tape system for helping you catch bugs and at the same time it's still quite performance anything lots of lots of high-level languages to give you easy easy expressiveness and see if you have very large compromises in the performance side and fro, it's much less so you typically won't be as fast as he could but you can get it within spitting distance ready willing to write the core of your programming to care for a way you can you can get Ocala for this quite close to close to the speed of see it's also
 language which is somewhat Hennessy concise and once you get used to reading a function language very readable
 but guess the kind of concision of a dynamic language with the full type safety that you expect from a language with a static type system
 I should eat it sits in a few different ways kind of sits in The Sweet Spot in the space of programming language design another another aspect of of the language which is very nice is its it lets you write things in the pretty declarative meaning to Curtis of funny words exactly what it means but roughly I mean you can write things that are pretty simple and pretty easy to read and understand that at the same time have quite understandable performance Behavior example of where you write your sequel statement and its in this nice higher form of it's pretty easy to understand what you're trying to achieve and then the the query Optimizer performs a miracle or doesn't perform a miracle and so the performance of a given sequel query can vary by a couple of orders of magnitude choices the query Optimizer made and it's out of your control so this is where you give
 precise control in exchange for having a very high-level language and gives you a quite high-level language precise control over performance which isn't unusual trade-off so you said that too useful characteristics of O camel are brevity and types how does o camel exemplified brevity and types so so important in in a way that is so useful to trading systems like Jane Street
 show forever Samira thing I think these these properties are valuable whether or not you're building Training Systems I think teksystems end and concise code is kind of universally a good time to have any programming language but the key thing that lets you have those two in the same language is typing this so that you get types everything expression you write down no camel the type of that expression is precisely known by the compiler but it's known by inference mostly rather than by you haven't expressly say what the types are so you should go back to like the order history of programming languages back like the 1950s wear that the early the first two languages that were endless was untyped in Port Richey reason for Travis type was for performance and Liz was untyped and they gave you before the better expressiveness and brevity
 and one of the reasons why I typed for so expensive in Langley portrays the way of expressing was very simple very concrete like every time you get a variable you had to say what the type of that variable is and probably the kind of ml family of languages have type-inference built-in in a very Universal way so that almost all of the types of you care about can be inferred automatically just by looking at the country things that you want to do an in-frame you add these things together they must be numbers and that kind of simple infant woven together over many different parts of program let the complete type of your could be inferred is there a performance penalty that code inference but actually are camels are quite fast compiler way way faster for example of a C plus plus compiler variety of reasons for that but there's a penalty
 what type inference example of the type in photography this use my email happens to be doubly exponential and it's kind of asymptotic so you can write a program that will not take check until the heat death of the universe but it turns out that programs that are hard to type check for the algorithm are also hard to think about 4 people so nobody ever writes them weirdly so even though in practice that the asymptotic so terrible in reality the compilers a great fast system through this this YouTube talk that you gave and you you mention all these interesting properties of the type system that parametric polymorphism algebraic data types Phantom types and you said that that is really the simple features that are actually the things that are are are more appealing rather
 the more complex feature so maybe you could talk about the simple features of the type system that are really important great so important to the first encourage polymorphism which even though it has a really fancy sounding name is actually a simple feature and the other is the presence of variance which is a key part of what we call algebraic-data-types talk about parametric polymorphism it is more or less the same feature that you have in language like Java called generics in Java and this is the ability to have some value or object or whatever else do you have in the language that is parametrized over some other time so for example almost everything that you can think of has an array type and you typically can instantiate the array type in multiple different types for the container so you can have an integer array or floated float or a or
 array that has pairs of integers and strings or or whatever or there's a free type parameter and parametric polymorphism is default kind of polymorphism in and as opposed to a language like Java where the default kind of polymorphism is what we call subtyping write the kind of is a relationship this is a guy and I think it turns out that most of the time the kind of polymorphism you want is this thing we call parametric polymorphism and not subtyping they're both useful but if you have to have to pick it up fault parametric polymorphism I think the more useful one and it comes up a ton of things like containers so for example if you think about the if you ever want a function that is going to eat over a container and say find the sum of all the values or maybe combine all the values given some function that you pass in to do so
 the natural type of that is kind of a type parameter we should say you wants to be able to do this given say any function that can combine things of the type in the container class the type of the the things in the erase a and an array with that same type of gov element you want to be able to kind of pulled over there rain combine all the elements into single call you maybe the full function is summation or maybe it's Max or whatever happens to me if you're pretty good application but this kind of generic iterator is naturally expressed parametrically meaning the the the typer talking about we talk about the containers is always the same where is in an object oriented language with a normal thing as subtyping the different things that come up a different instances of the thing that are generic you say well it's some subtype of maybe not the same subtype
 so it's kind of the fundamental difference between parametric polymorphism in subtyping where subtyping is all about I want something that matches interface with anything that matches the interface will to and parametric polymorphism is all about there's something in here I don't know what it is but once I decided what it is it's always that same thing
 and
 is it is in service at this whole description is sounds so fancy and and I'm getting very hot on it all sounds more complicated than it really isn't practiced by for people who are wondering maybe what the root is of all this type of work was so beneficial at this type system is it is it that these texts and just allow you to catch more errors at compilation time so I think there are two things that having Wellness back up
 how to get tape system at all and is having a really rich expressive pipe system so I think that one of the things that having even a very basic types of some gives you wish people often don't think about is truly just the basic idea you like features of being able to look up the values of things and look up the types of things just works much better in a language for the types of stuff so that's kind of wanted to get you before you get to Lover's like it like ml just having good types is very valuable there another kind of tooling aspect of types which is very nice is that way you have informative text to tell you what your functions might do you are object might be constructed the types of cells firm is serve as a form of documentation and I'm like every other form of documentation you find in a big coat base is documentation to lie to you
 the thing to type system says that contributors compiler checks it
 what do you get by moving from a fairly simple and not terribly expensive type system like Java's to ask someone richer one like the one in finding a language psycho camel and I think the key Advantage there really two of them one is it makes lots of things simpler to do there lots of case we have to work around Chaves type system to get the behavior you want and have to do lots of kind of complicated Declarations of thing to make it clear what you're trying to do like a really stupid but simple example is if you think about Jabez jx95 didn't have generics it took some Haskell programmers actually to bring generics in Java and Java before she asked if you wanted to return to things like what did you do
 well you could like create a new class for expressing that there are these two separate things that you want to return
 in someone richer languages that have parametric polymorphism you can see a general thing I have a notion of a pair I don't have to declare it every time it's reusable I can use any different kind of pipe inside of it so send it to return a pair of it into the float and some time to return a pair of characters whatever I want to and I don't have to say extra things to the type system to allowed to let me do that also having more expressive types lets you do what you want to do without having to talk quite so many forms are you can do things with less for their plate
 go ahead and then the other thing is they do in fact catch bugs attached lost more bucks I think that is a lie that ml program which is that you know when you when you write your program in in Ocala or a similar language you know what it compiles basically works and this is unsub Simpson absurd lie there lots and lots of kinds of bugs that aren't caught by the type system but it's also shockingly close to True a wide swath of trivial bugs that you're used to having to sweat over just vanish in a system like a camel I think the one that's maybe most readily understandable is null pointer errors that when you start adding it's hard for people to too kind of fully take on the fact that when you program a new language you basically don't get no quarter errors there's enough support in the language to more or less with the types to prove that those can't happen and and that's a surprisingly effective
 no pointers are just one kind of air this whole other set of errors that that disciplined and carefully to the type system can make vanished big vanish with relatively little effort what does property is avoiding null pointer areas within functional language is seems to be a theme we did a show about Elm which is kind of like this Haskell that has a castle meets JavaScript basically and you know the people were talking about rebuilding their JavaScript applications but within Elm and never getting a undefined error and that's kind of unique cuz in JavaScript General your writing code when you get all done to find all the time and if I did not a variable or they're out of function that's what it says so yeah that's definitely resonates is a motif there so you mentioned this this boilerplate avoidance that you get through
 using Oak Hamill an interesting quote I heard from you is you cannot pay people enough to carefully reviewed all code and yes you are saying is like Boiler boilerplate code is boring to read like people don't want to read it and so they won't read it and then so you can end up with like errors in the boiler plate and they're just like you know and then screws you somehow so could you clarify this reduction in boilerplate code how does that work how does or are you saying the old camel makes the coaches more interesting to read what do you mean by that so I guess this two kinds of boilerplate they're worth distinguishing one is kind of type system boilerplate which is where you have to make a bunch of decorations to explain to the compiler what it is that you're doing
 and that definitely makes the code harder to read because it's kind of inserts all this noise around the logic one of the nice things about a camel's if you write you get you get code that is about as concise as python but with the performance and correct properties of other types of language and because it makes things easier to read what is one way in which one kind of boilerplate you avoid but more generally woman go camel is really good as it gives you good abstraction tools good lightweight ways in the language to take something you need you multiple times in a row in the same way and parameterize it's a rather than read rewriting the same card multiple times I'll just take a little function made to find locally that takes a few different arguments and then does the appropriate thing and then call that function a few times and now the different implications of the function clarify what is difference between the
 different times you had to do it and make it explicit what's the saying that what the function did it does the body of the function is the park is preserved and then the argument just the part that change from location to location to form of compression right where you can take the repeated parts and thoughtfully Factor them out so you don't have to say the same thing over and over just the well-known you know I don't repeat yourself principal about it but different languages support that two different degrees and you want I do need to have a language which lets you do that effectively a language which doesn't give you much in the way of abstraction tools like this is see when you talk to really good to see programmers about how they deal with a boarding repetition
 we sometimes resort to prolific use of the macrosystem using pound to find two things like that to get around the fact that sees abstractions are relatively weak in this regard but that has the whole set of problems on its own macros are much harder to reason about them functions and so just make sure code
 what is the difference between a macro and a function
 that's a good question if you can think of a macro as a function that transforms your program right it generates code rather than just doing something you can think of a function to something that has an abstract definition and then the use of the pumpkin don't have to think about what's going on on the inside where is when you drink syntactic Transformations as a lot of complicated things that can happen that are hard to think about one of the basic ones to be concerned about his variable capture where if you have a macro that like takes in some some names of variables that expands to coach Sheraton code around them one of the concerns you have is that one of the variables that you might reference new generator codes might happen to be also referenced by the variable that are passed into the macro and because you just writing to write code to can easily write bucks in that and falsely identifying variables that are not supposed to be identified
 where has got you thinking or do you call a function you're never exposed to this kind of confusion the name of the function on the other side is a kind of irrelevant to say the name of the argument you pass to the function is a kind of irrelevant detail of a syntax which never interferes with the meaning of the Cody reading
 we'd like to take a moment to thank our sponsor digitalocean offers simple Cloud infrastructure for developers in one click you can have a mean stack or rails application in Ubuntu box or another custom environment software engineering daily is proud to have digitalocean as a sponsor because digitalocean is the simplest cloud service provider by the interviewed noisy oretsky who is a founder of digitalocean and he told me that digitalocean was based on this realization that other cloud service providers are so complicated if you want things to be simple when you deploy your application use digitalocean to try digitalocean go to digital ocean.com in interpro MO code SE daily that promo code is 1 word s e daily now let's get back to our show so we talked about a lot of the benefits of a camel and I would like to touch on some of the weaknesses and how those weaknesses change the programming model at Jane
 Street what is the concurrency support for Oak Hamill worth separating between too confusing and very similar words concurrency and parallelism parallelism is about taking advantage of multiple pieces of hardware at the same time do things physically in parallel and concurrency is in something about programming in the presence of inserting physically uncertainty but when things might happen to a concurrent program is one where you have lots of things going on kind of logically that are being tracked by the program in some sense at the same time but not necessarily using multiple pieces of Hardware to do it so a good example of a program that can be concurrent but not parallel is you might write a program that listens on the network and gets has connections to many different servers elsewhere and is sending and receiving messages from all of them and you want a logically describe different parts of the program that are sending messages to
 I'm waiting for responses from different things all at the same time and it's uncertain about what was going to happen next and for that you need some good model for writing these complicated can current programs and then at the same time parallelism is just as free where you want more performance out of this and you can use concurrency to implement parallelism you can have lots of things that are and sending messages to other and waiting for input one from the other and that's the way of building a distributed or Carol system Albuquerque different concepts
 account has a very straightforward and good concurrency story which is there are all sorts of useful libraries we should give you a beautiful abstractions for building concurrent programs that we have called a sink which gives you what model based on what are some teachers were future is a value that may not yet be determined by using these little kind of combining functions often called carbonators that let you string together competition based on these Futures where you can hate when you can say I going to call this function which gives me back about you as a future and then I'm going to attach to that another complication with you when that future is filled in that the next month will be run you can get these sensible sequences of operation that can you have multiple is combined in the same program and because you have control over the entry leaving your Wendy's things can switch control from one to the other
 it's a lot easier to reason. The interactions between the different pieces so the normal probably run into you where you have lots of concurrent threads walking over the same memory space and you have to use mutexes and condition variables in semaphores like that kind of puts incredibly hard to reason about and abstractions like a sink give you really good ways of writing programs that are really easy to think about
 but will Campbell story is less good is parallelism doesn't have any anyway running multiple threads that share the same memory space that can use different Hardware the same time so you can't saturate you know the 8 cores on your box with Joe Camel threads running inside the same account program what you need to do there if you have to run multiple account for them to communicate via message passing and this is the way in which we've built our systems here and it's actually been really good we really like this approach and actually work going on right now actively pushing to have a multi-core garbage collector so that you could have multiple threads inside the same Ocala process and taking this is a good thing for the community because people care about it but we suck Lee was how we're going to use it
 because we can and do build highly parallel systems that can use massive amounts of computing infrastructure but we just do it in different ways and in one of the nice things about message passing is you're not restricted to a physical box that you can ride systems to scan multiple boxes using the same set of abstractions
 Usher
 choo choo we don't have shared memory parallelism that's just not a feature of the account because right now my guess is a year from now we'll probably have will probably have about as part of the ecosystem but it's not clear to me that that is a thing you should want in particular within finances their sum is there something like risks to the shared memory that you get to avoid by not having that level of parallelism
 or rather to achieving to parallelism the different way and I think yeah there is something there is a lot of risk of your voice because writing shared writing code that uses the same shared memory and and kind of interact with it in an efficient and correct way is extremely difficult so we don't have any have set up explicit shared-memory segments which different programs will reach you in reference to communicate with each other but we don't have it is part of the kind of warp and weft of a program where kind of everything might be shared when we have Sherry we kind of have explicit regions cordoned off in which we do the sharing and thinking about those actually really hard like a lot when we the last time we went to to build one of these abstractions like we literally went like dug out some papers about how the x86 memory model Works to try and understand that better because it's actually really subtle and if you going to be the Intel manual
 tell you a bunch of hard to understand lies that I could don't correspond to have a hardware works and that's because the memory models you can get from inefficiently are not simple in there until one is pretty good it's relatively simple of these go but does naive memory model that everyone has it like oh there's a bunch of memory and then you know different things are reading and writing from an it all happens and some order like that just doesn't work that's not how things happen when they are caches you know I might write something you might know and you might write something and the order doesn't like one well-defined order I wish you could imagine the whole thing happened explain the point of view of the two different actors on the system
 should American currency is complicated hard to think about it in if you're if you're working in an imperative context or you like you're actually doing mutation which functional language we write a lot of imperative code no camel and end, unlike say Haskell's language where you can do you can write in her to go anywhere there's no constraints in the type system stopping you from doing it in that kind of environment having lots of thread to share the same memory space it's very hard to reason about and I think anyone is really concerned about correct this should think twice about programming in a kind of free thread model where you just have to like it when I have to be great to Splendid put all the locks in the right place to make things work well that's very hard to get right
 now that we're kind of on the topic of distributed systems I'd love to get a better idea of the larger architecture at Jane Street and maybe if you have any interesting distributed systems stories are some problems that you've been working to solve be great to hear an anecdote or two
 sure so I guess one interesting so the whole question of how to shoot a system should be designed as one that is because my academic background is actually in distributed system so I went to grad school in and had lots of plans to go off and be a professor and I learned a lot about all sorts of clever algorithms out there for building strictly consistent replicated systems which is one of the core things that that destroyed the distributor system literature talks about and if you look at companies like Google and Facebook and so on and so forth they actually use these Primitives in their own system so for example Google has a system called chubby which is their lock server and it's a distributed system you have multiple different chubby instances but they try and prevent an illusion of one consistent system and the use a bunch of fancy algorithms in particular that they have a variation on it
 which is a well-known algorithm conditioning systems literature which is legendarily complicated and hard to get right so one of using attitude about this year's back whenever Insurance a very smart guy named ed Yang after having done some other kind of more directly useful stuff we thought it kind of is a flyer why don't we go and use our nice concurrent programming library to go in till 2 packs of supplementation let's see how well it works and he went off to build one in the end came up with a nice implementation that we could experiment with but along the way they were so I didn't question about exactly how to put the algorithm together and so we looked at one of the paper to Google to publish on the topic and they had some nice trip to describe for making basically you show me some technical aspect how do you group membership
 the set of post that are involved in this to shooting system making that easier and his part in there in that album intros that didn't quite make sense to Ed and he said I don't think this is right and I looked at the code NFL yeah I don't think that's right I don't see why that would be correct and I emailed my one of the guys at work with back when I was in grad student just bring the number of paper in the area he said no I don't think that's right and I want him he was a guy who's papers I read when I was a grad student on the same topic and I pointed out he was like yeah you're right that's a bug and Cheetos to them for having like a correctly described in their paper well enough what was going on that that
 that that you can really understand because you will have to find a bug in it I was pretty good as opposed to the original fax this paper and paper by Leslie Lamport I recommended it is completely incomprehensible and it's extended allegory of a distributed system as if it were a Rowdy Parliament on the Greek island of taxes it's hilarious but very hard to understand and then he wrote another paper called taxes made simple and then a guy I know and do like a long series of papers about trying to understand the first packs of paper he submitted it to ACM and it just didn't accept it cuz I like Sky's clearly crazy
 I hadn't heard that story actually I like figured out how to how to do distributive systems so I think an interesting question here is whether or not the whole idea of taxes is as Brawley applicable as people think it is it's very hard to get past this correct and the Beast where did you have some well-defined notion of what are the things the sequence of things that happened to linear order to all the events and you have to find a way of decoding goes against in building up a state that's the part that the state machine and if you can have a way of describing the events in the same order to everyone reliably then all the replicas you just follow along decoding the messages they go and you have a very easy to think about wave replicating the system
 the fundamental problem packs us to is trying to solve the problem of what happens when the guy who's calling tune the part of the system is deciding you order a vest what happens when that thing dies and one of your experiences we've had tears we built a system along the same lines that that is a is built on state machine replication where do you have a part of the system called the sequencer with sides on the order of events for everything but when the sequence who dies what happens if a human has a key step in and manually kind of do some checking and make sure that like the thing that died in half alive and still generating message make sure it's actually been dead before flipping over to a back up and do you have a few minutes of downtime as someone who thinks through this somewhat complicated situation and and that's the time when the master dies you have some extra work to do they have to be careful about to recover
 description of at what point is is the extra complexity of implementing these fancy algorithms worth it given that if you buy a nice high-spec machine
 it's medium time to feel yours like once every 2 to 3 years so if I could take it down time of 3 minutes every 2 or 3 years it's not clear to me that all of the complexity of taxes were doing and even beyond that the number of bugs you expect from the Packers of limitation be wrong as I think probably larger is the number of bugs that you expect from urine odor nice high quality dual dual power dual networks machine crashing safety versus live next to you're talking about that's right the password I actually think is important in some application areas but it's a kind of trade when you make the system more complicated and thereby implicitly trade Away safety in in exchange for a system that's more live in really more life in an automated way if you look at a solar system when the leader dies because in the end they do what they do have a leader that is making the
 what the next transaction is a little bit of latency as much is the down time is less and importantly it takes less operational kind of work and less operational know how to do the feel but you don't have to have a smart person who's thinking about it it's going to happens in the background and yes you were out for a few seconds but that's not that big of a deal is kind of like a win-win there right as I've heard about Raph it's like you kind of just get a little more Simplicity can I get app access like system with more simplicity so I think raft is it seems like an honorable directions to try and wrap is the papers myself but talking to people about it getting somewhat simple in pax's still not I think erratically similar
 write an email to systems like wrapped there's an enormous performance turn off so systems that are built with a single sequencer can do millions of transactions a second you can write extremely fast Network processors in Ocala right without without without going totally crazy you don't have to like decide to rewrite everything using fpga or something you can do camel coat on on basically stock ordinary Hardware you can read things you can process millions of messages second and get messages in and out of your box wire to wire in a handful of microseconds right it's just not that big of a deal and you cannot do this any taxes like system is just no way so you're making a lot of sensible applications for it and then maybe the things like chubby are totally sensible uses in and also the zookeeper in think like that in fact we're starting to use to keep her a little bit in
 but my guess is that people over apply things like paxus and think it's relevant to more to me than it really is and what all kind of surprised by that seems like your kind of advocating more live news less safety and we started off his conversation emphasizing the need for safety particularly in your domain so do I think I think the thing about having kittens actually more safety and less life sucks it stops called so that is that's a live this problem of a safety problem and it's not you know
 the platonic ideal of yog rooms at least are totally safe right there's nothing nothing wrong with red patches of pigmentation but as a kind of practical software engineering matter generating a correct Paterson New Edition is not easy I think I think it's a little bit like the cryptography story is not one of these things you should consider rolling on your own it takes a shocking amount of engineering to to get a patch and it's not clear to me that I would feel good about a pastor's implementation that didn't have a formal proof of correctness behind it like that so
 well I guess it makes sense that you're using zookeeper then since there's so much so many eyes have covered zookeeper your pie a lot less likely to get some the type of less safety due to lack of eyes on it that's true and you're not using zookeeper for things that are absolutely correct is critical we build stuff that sends order to the market and we also build build system and we build monitoring tools we build things for deploying server as in not everything the infrastructure is generally important quality but not everything is equally terrifying to get wrong we apply different engineering techniques to different parts of the system interact with the broader Market you said that it's terrifying to write software that interacts with the broader Market that interfaces with the broader Market why is that
 should I order a couple things what is just the fact that these
 these systems are trading on on your behalf are committing you to the transactions and you can lose a lot of money on those transactions and if you have a system that makes to seem stupid decision over and over in a fast loop you can lose a shocking amount of money before you noticed so it dishes and something about the messy details went back and got the more about the core semantics of what we're doing right now we're treating treating a scary having this thing happen without you an oversight but just being by some program it so you know for programmers like just wrote and tried hard to get right like that's a scary thing on its own
 it's all me much worse by the fact that the world is really complicated and hard to model there's a big gap between the Snivy model you might have how the markets work and how they really work if you could always rely on the fact that you were treating the symbol you thought you were you're treating me instrument you thought you were trading in the market it you were getting was good and you had your correct understanding of the word meaning in all the different corporate actions that could affect the meaning of the Securities neighbors yes they were clear and you know when you have complex security relationships I'm a little drunk and I should maybe explain but they're kind of obvious examples are things like if he ask security that represents a basket of other Securities that ETF means and it may change the way that you don't understand in somebody else does so there's lots of ways in which the gap between your understanding and what's really going on can can mess you up
 and that adds a lot to the complexity of it and it's made worse by the fact that Financial software a lot of it's really terrible a Wii trade-in markets all over the world and some of those markets are not super well-engineered and so are you try especially when trying to break into new and more obscure things you discover all sorts of weird stuff in the technology works you want hard guarantees I want to know that I sent an order for 5,000 shares and I want to get to feel the price no worse than $33.30 I want to know that I don't get billed for more than that number of shares are there any worse price simple Bay security to want and it's not one in every exchange everywhere successfully honors veggie is this like a zit do you just have to have an Institutional humility cuz it sounds like there's just so many like Black Swan type of things you have to be prepared for
 whether it's you know eat an ETF doesn't trade the way you wanted to or there's a glitch in the system or I like how you institutionalize being prepared for this type of stuff so I think it is a great way of putting it I think that risk management extends all the way from the technology stack to the trading decisions and you need to be afraid of the various things can go wrong and we try and be very careful trying to think hard about the kind of things that we don't expect might happen about different ways in which the different risk were worried about try not to be correlated with each other that's I think one of the scariest things about the financial world is when things go wrong sometimes all go wrong at the same time like exactly the time when when
 the exchanges bugs are likely to be exposed is when things are very busy right and when things are very busy that you have violated
 so you get all sorts of things at the end into another terrifying to imagine when the markets get really busy no one else might happen your monitoring
 Richard to be simultaneously exposed to weird behavior in the financial markets and large amounts of trading and failures in your monitoring and then weird failures in the semantics of the underlined system to dealing with you just have to be afraid of all of those things and think carefully when things are going wrong about what might be the cause about it and when things look like they're going right should be a little worried about maybe they're going wrong you just don't realize it do you have like a big red button that you can press to shut down the system we have lots of ways to Trinity's off big red button I see I like to say that shred it cuts the power within the heart beats other things he keeps him alive like we are I like to I like to think of that one of the most carefully engineered abilities of our trading systems is the ability to not trade
 we tried with Dudley engineer that into the systems fire alarm do you have an inverse of that like a big green button to press in moments of severe volatility
 so I know so I looked back and I think that one of the things that is a pervasive part of our around software is that the idea that not treating safe and so there's a default that when things look bad you should turn off now you got to be careful of this because from my point of view of of doing a good job at the actual business you want to be up as often as possible where there's a service that you are providing to the markets you are you are being the other side of peoples trades and when things are complicated in crazy that's when people need your services the most and are willing to pay the most for your services so you are very well compensated for being up and trading in crazy times
 but even so we feel strong it is important to engineer the systems to turn off in when when things when when things go bad at all right so if you have some crazy situation of your code you like what what it what is this happened in the other happened I get this weird Corner that should never really happen well we really say well the right thing to do is to turn off and this is very different from out of Facebook where do that I think availability is King like if they show you know the wrong set of likes it's just matter that much but if they're not off everybody's angry clarify what I meant by volatility I meant like let's say there's a war you know a war breaks out somewhere totally unexpected or like a plane goes down with a president and it and it says type of situation where it's probably not going to lead to like Market glitch or something but it's everything we're like you you know maybe you've got a bunch of positions that benefit from Market volatility and then you would want to press the big green button and take advantage of that
 maybe that's something that just doesn't make you excited I don't know what that green Buttonwood do but wanting one of those CDs did I think that the day that they're so yo did it like you're some terrible news that makes the whole markets go crazy that is it they were you expect bad things to happen on the software so you'll have undo load you have wished we should do you don't normally have so these things are really correlated another good example of correlation that this is not a bad event but Facebook's IPO was a huge event on the market and it cause massive disruption for Nasdaq those were not uncorrelated you didn't happen to have a system failure on their opening on their opening crossed just like on the data Facebook have an IPO there were specific features of the Facebook IPO that made that goes out that exposed problems in their architecture and I think this is the way of things
 the extreme circumstances for a financial sense are also the extreme circumstances from a technological said that Jane Street works as a technology organization potentially four ways that in a listeners might be able to apply to their own companies what are some unique principles at Jane Street
 so I don't know if I quite elevated to a principle but we have a very strong focus on readability of code and on code review I we put a lot of effort into tools for code review us we have our own call the iron that is used for basically all of the development that we do here and one of the reasons we care a lot about Twitter's use that one of them is justice issue of
 it's a way of catching box but but I think it's attacking much more important than that it's not just about making sure things are correct
 cougarview is a way of doing a lot of good thing to your car based its way of sharing institutional knowledge right in front of your bus factor multiple people reading the codes and you know the one person getting run over by a bus is not completely destroy all of your institutional knowledge of the system question to great people and I think more than anything else improves the Engineering Systems because it obligate you to write systems that are possible to be read write him in readable code I think it's very different and in functional ways off and much better than code is unreadable capable of beating simple enough to be red is also likely to be easier to modify more likely to do what the people who wrote it intended easier to evolve to do new things so I could use a big part of our of are institutional cover purchase software and Sunday even though we lost please have country I think we spend more time on it in and think about it more careful
 any organization I know about got it to close off I'd like that's kind of philosophical question how has your definition of money changed since you began working at Jane Street on these Financial Technologies
 so I don't know that my definition of money has changed exactly but I do think very differently about the idea of will call expectancy right thinking about what is the value of a certain choice that you make in monetary or in other terms and I guess so when I started I changed it back before I started I was doing some Consulting for the firm for about a year halftime while I was doing a postdoc and one of the early people that I was talking about what was going on he said you're what's the chances you want to leave early before the year's out what's the chance you want to stay on permanently and I said 0
 and his immediate response was to kind of laugh and say I'll buy that wishes to say he'd be happy to make a bet with me that there's some probability that I would stay and the is thinking about how I think about these kind of things now versus then like I would never think it was almost a violation of my professional ethics to describe the probability of something is being 0-0 probably be true is if you think of it in a kind of Bayesian sense is like saying no matter how much evidence you can show me on the other side I'm going to still believe that it's not true they got himself could descend from heaven and say you are going to continue working a chance read after the following year and I would just continue not to believe and I think this kind of ship in Focus I think it comes from thinking about the monetary implications of your decisions one thing that that is a very
 Aerotek Racine over and over is that when you ask someone to try to ask me how confident they are about something I like you something is true you'll do a terrible job of it very often being naturally overconfident how much money would you bet on it you know and it what odds you see suddenly like step way back and think much more carefully about it and see things that make a lot more sense so I think there is a real way in which thinking about the monetary consequences of your actions helps you think about probability in the more rational way
 yeah that I definitely remember feeling that way so play a lot of Poker and it to your point I remember reading this quote from Dan Harrington is a poker player and he was like you should always the minimum probability for your that your phone is bluffing is 5% in any given situation and kind of this floor on the fact that your opponent is just full of it that is not zero was always kind of interesting to me and I definitely found it to be a useful heuristic does not necessarily an intuitive one you would assume that grandma isn't is never bluffing or you know something like that but it in fact this is actually I know it's it's it's useful here at 6 I really like that that probabilistic model of thinking right you never exactly anyway well your own Minsky thanks for coming out of software engineering daily it's been really awesome and
 interesting talking to you time flew by great thanks so much
