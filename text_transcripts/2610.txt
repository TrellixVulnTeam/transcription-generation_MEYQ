Transcription: JavaScript programming usually is done through the use of Frameworks such as react JS angularjs and Ember JS these Frameworks abstract away some of the messy details JavaScript and simplify web development so the engineers can build products at a faster Pace when we build software using JavaScript Frameworks we are missing out on some of the richness of the JavaScript language itself in exchange for faster software development Kyle Simpson is the author of you don't know JS a series of books that suggests that JavaScript developer should start from the ground up not from the top down by learning the basics of JavaScript a software engineer can learn the Timeless fundamentals that will not disappear with the creation of next week's hottest framework after exploring the idea of Frameworks versus Raw JavaScript Kyle and I discussed asynchronous JavaScript from concurrency to The Observer pattern
if you enjoy today's episode about software engineering daily please share it on Twitter or Facebook tell your friends about your favorite episode that's how this show grows through word-of-mouth you can also send me an email at software engineering daily at gmail.com I am always looking for criticism new show ideas just people saying hi thank you for listening to the show and I hope to hear from you soon
 software Engineers never stop learning if you were listening to software engineering daily right now you enjoy learning so much that you listen to a podcast about technical software topics itpro TV has videos for people like us people who never stop learning I'm using itpro TV right now to learn about Amazon web services and I found 10 hours of high-quality videos about ec2 elastic load balancers orchestration cost management if I ever decide to start my own company I will need to know how to manage the cost of my servers go to itpro. TV / SE daily to get started with a free 7-Day trial videos you can then use the promo code SE daily and get a 30% discount and that discount is permanent watching these videos I have learned how to configure Auto scaling groups to get
 load balancers I've learned how to configure a database that can scale up without inconsistencies if I wanted to test out of the Amazon sis Ops certification right now I could there also courses about Microsoft operating systems and networking VMware virtualization Cisco routing you can watch 70 hours about Cisco routing and switching and it is engaging and entertaining material if you listen to software engineering daily all the time this is the kind of material that you will love you could put it on in the background and you will find yourself just absorbing the information without even realizing it you can try it free for 7 days go to itpro. TV / SE daily use the promo code SE daily to get 30% off and after you try it free for 7 days I have no doubt that you will want to continue to invest in yourself and your future
 thanks to itpro TV for sponsoring software engineering daily and for producing this top quality content
 call Simpson is a web evangelist in a published author of several books about JavaScript Kyle welcome to software engineering daily thank you so much for having me the first book in your you don't know. Jas series is called up and going and it's a great introductory introductory book to both programming and to JavaScript itself in this book is it's great and it's free so I encourage anybody who's listening to check it out one main point of the book is that you encourage people to dive deep into the finer points of JavaScript itself so on this show we've done tons of interviews about react and fujs and angular is it a Frameworks why do you encourage people to learn JavaScript itself rather than the Frameworks yeah it's a great question so as you as you mentioned that the series of books are six books in the series the series of books is designed specifically to challenge the popular notion that seems to be quite trouble
 in our industry challenge this popular notion that it's enough to just know enough JavaScript to get a feature implemented I have a feeling that many listeners have probably been in that same position I certainly have in many many years and my career not understanding what I was doing but it just sort of worked and I like to call that house of cards development so to set something up get it to work and hold your breath as you back away maybe put a little comment there that says don't touch this cuz I don't really know why it's working so please don't mess it up and so that is a is a problem thing it comes from the nature of the language itself JavaScript has this two edged sword that it is so easy to get started with the language which is its greatest strength it's the reason why the language won the ubiquity Wars it's the reason why it's become the the lingua Franca of the web is because it is so easy and it's so accessible to so many people easy
 learn about the other side of that sword in the cuts pretty deeply I think is that the language is far too easy to learn only a surface level understanding to use a framework to apply something a library jQuery not critical thinking about what's going on underneath now I want to be careful to say I'm not suggesting that every person have to be a framework or Library level author to be in a valid JavaScript developer but I do think that it's important for us to understand that a confidence level the tools that we use and for us that that that tool is Javascript even if you call yourself a reactive eleveur react this just JavaScript it be a little bit like driving a car and having absolutely no
 notion in the slightest of what was under the hood you don't even know that there is an engine you don't know how it works you don't know that it runs on gas you don't know that there's electricity that runs the radio if you had no intuition about those things at all you could still drive the car and you could probably be pretty successful at it but that's the happy path when things go well many of us developers probably identify with the not so happy path when things don't go well and in that metaphor of owning a car if you went to the repair shop and you literally just kind of threw up your hands and said I have no idea it broke I don't know you're at their Mercy at that point on the other hand if you had some confidence you to say you know I think it's the brakes they seem to be squeaking and I think it's the brakes then you can narrow down and start to have an intuition about where the problem might be and be able to reality check against what a repair person is telling you that's the level of Competency that I encourage everyone to get to
 JavaScript can beginners learn this route effectively can they begin learning to program even with just Ross garage office rather than the Frameworks yeah because I actually have a different definition for what a framework got to be in this part of the a little controversial it's not new I've I've said this many times publicly but I don't think the purpose of a framework is to learn the language as most people do I think the purpose of a framework is to assist you in rapidly prototyping so if it's not to learn the language but to assist with one particular part of the development life cycle then what we have substituted for learning is what I would refer to as basically just rote memorization I don't really know how it works but I know that I've done it before I know I can copy and paste this thing in and it'll repeat itself the way it did the last time and we sort of take that as good enough and I don't think good
 is actually good enough for us for those of us that want to take being a JavaScript developer seriously but JavaScript Frameworks are a higher level of abstraction been raw JavaScript in it if you are going to suggest that people should focus on Raw JavaScript is that a say that you could just go further and encourage them to an even lower level that they should learn Assembly Language that they're not actually your they're not going to know what's actually going on less they know exactly the physics of what's going on in the processor how deep does that argument go yeah that's that's a real common argument people say well let's just all go back to assembly that's the the slippery slope logical fallacy so I certainly don't Advocate that unless you know machine language you can't be a developer what the way I choose to articulated is this if we look at the history of computer languages they have been classically divided into Generations
 depending on who you talk to and what Wikipedia page you read JavaScript sit somewhere either in the 3rd or the 4th generation of programming languages when I was first learning it it was more call the 4th generation language and now it seems to be more referred to as a 3rd Generation language But whichever place you can you put it there are these distinct divisions and it's pretty classically understood that machine language being the first and you know it an assembly and then above that in the second generation being languages like C and so forth so using that as our guide I think that whichever one of those Generations you choose to make your career in and some people of course cross boundaries but if if we're talking about specifically developer that focuses on JavaScript whatever generation you're in I think that you should first sink Mastery of that generation and a confidence at the generation below it a confidence of understanding so I is a devel
 would not consider myself a C programming expert but I do understand a little bit about what she is doing and that assist especially for example in the note World a lot of the libraries that are exposed in the notes you know system like the file system commands those are all posix inspired api's comes directly to us from the tradition of C programming so having some confidence understanding in that layer allows me to understand what I'm doing better I don't have to be a c expert or an assembly expert or machine language expert but I should know the layer that I'm at and be confident with the one below and when we talked about within those layers within those Generations we talked about all of these magnificent libraries and Frameworks in even platforms that are created within them and I think the same principle applies at the micro level as it did it the macro-level meaning of whatever generation or you know whatever part of that layer whatever strata you choose to play on you should be extremely familiar with that and you should be
 confident at the one below so if you intend to make your entire career as a reactive Ella / then you should fully and completely and totally understand and you should have a solid fundamental competency of the layer below that which in this case would be JavaScript if you are choosing to make that decision I would be remiss if I didn't say that one of the reasons why I encourage people to really learn JavaScript itself and make that be the focus of your foundation of learning is because those of us that have been around long enough to know that there is no Silver Bullet where we've just we've been waiting around for decades for somebody to invent the perfect approach and now we you know a lot of people think react is the thing but I promise you three years from now we'll be on a podcast and we'll be talking about some new thing that's even better than that and some new thing as several years later these Cycles repeat I've seen it for 5 times just in my career
 recycles repeat so the thing that is true across all of those Cycles is that having a better understanding of JavaScript allows you to better and make those decisions about how and which tools to use right now a lot of developers make the decision to jump on react or angular or whatever mostly based on signals like how many GitHub stars does it have how many votes did it get on hacker names that sort of thing I don't think those are actually very good signal to make such important decisions I think the best signal that you can make is to actually understand and the the mechanics of what your applications going to need to do and then be able to look at the source code of a framework or library that you're choosing or even platform and see whether or not there's a good match so I don't tell people go make your own react but I do think that you want to be able to open up the source code for react or for angular or whatever and understand every single line of it and if
 you can't that's the place where I would recommend more and deeper learning a brand new programmer the biggest risk is that I start programming and I get frustrated and I don't see the results for my program and quickly enough I write hello world that works I read some math functions those work but I don't get to a nap quickly enough like I feel like for a beginner what you know getting on board the the most important thing is to see some positive results really quickly in the best way to get those magical positive result is to get that massive sense of Leverage that that modern programming can can bring a developer so it would it make sense for a brand new developer to start with a with a framework in the sense that just gets them going faster and get that positive feedback loop going and then you know maybe when you get to the
 intermediary level where you like okay I've built some apps with this framework then it makes more sense to to delve deeper into the source code of the framework challenging the notion that you just asserted which is quote the most important thing is and you filled in that blank by saying getting some quick wins essentially I don't think that's the most important thing I don't think we have historical precedent the teaches us that that's what produces the most long term and productive and effective developers I think what does actually produced the most long-term effective useful developers to the ecosystem is a love and a curiosity to understand everything that they do at a deeper level at an uncommon level I think history Bears out that those are the people that have made the biggest and most sustainable impact
 so I don't think that quick wins are actually the thing that we had to focus on the most at the same time I do understand human nature is to say if I can't understand something quickly enough then I can't you know I can't keep my patience level up so there's a balance here and to understand that balance or how I would articulate that balance we actually need to address I think I'm misunderstanding around the terms of libraries and Frameworks and platforms a lot of people throw around the term framework and then they use that word to describe something equally like react and angular and jQuery and those are three very very different things and I don't think all three of them deserve the term framework so my my answer or my way of articulating this would be too kind of artificially draw three categories Library framework and platform and I'll start by giving you a
 4 and then come back to where I swap things in there but the metaphor is this if you're in a car and you need to get from point A to point B the old school way and I'm dating myself here of course with the old school way of doing that if you need to know how to get there is to pull out a folded paper math out of your glove box and look at the roads and figure it out and that map then is a tool that allows you to figure out the answer and get to where you need to go but it doesn't have any opinion or any guidance for you on the right would do that it just provides the information and assist you but it's a passive tool
 it was good enough for many hundreds or even thousands of years but it's not the best that we can do so then we started creating more advanced navigation tools so the second level then would be GPS systems in our car is he put in 2018 point B and the GPS system the navigation system says this is the best way to get there I've taken into consideration all the traffic and weather and all that other stuff and I'm going to tell you this is turn left here you're still not required to turn left if you know that that road is shut down and the navigation system doesn't you can turn right instead you have the option of going outside of it but it's going to be very vocal about its opinions about how it thinks that you should get there. Tool in your GPS systems that's at the second later and then at the third layer is a self-driving car you sit down put in point a and point B and step away from the steering wheel and it said
 will you get what you got it's going to take you there the way it thinks you should get there and you're not really going to have an awful lot of say-so in the matter you kind of take it all or nothing so if those are three layers metaphorically let me relate them back the folded map in the love box is like a library and I put things like jQuery and even to some small extent something like backbone it's kind of on the edge but I would put jQuery firmly in the category of Library it is a passive tool it has a lot of usefulness and I still endorse and use and even teach Jacqueline but I don't endorse and encourage you to use it blindly and not have any intuition specially if you need to optimize her performance
 let it the second layer and again all these lines are artificial so there is no hard-and-fast one of the other but at the second layer we start to talk about Frameworks and I would say that react is somewhere between the library and they're in the framework it firmly straddles the line between the two angular is much more firmly in the camp of framework by this definition of you and the others you know you can probably start to get an intuition of where you can slot those things and then if you look at something like Amber for example I think it's fair I have several friends in the Ember space I have a lot of admiration for it but I think it's fair to say that Amber is verging on the line between framework and platform Amber has moved much further along the lines very similar to rails it's become more of a you kind of just there's like one right way of doing things and it's not really a good idea to go outside of those lines and everybody has adopted the one right way of doing it
 so you can compare something like Amber to something like backbone and see very clearly that doesn't that there has to be some gradient here in the backbone World always used to joke you could line up 10 back on developers and get 11 different answers for quote what makes a back door now but if you lined up 10 Ember developers you're pretty likely to get almost the same story of what makes a good well architected and brown they made a lot of those decisions through a lot of really good intelligence and experience and when you choose the Ember ecosystem you are essentially choosing a platform that is going to guide you on the right path and deviating from an awful lot is probably not the most effective so if those are our three categories tools like libraries Frameworks that are more opinionated and platforms that really are very strongly opinionated in guiding you I think the most effective thing for people to use to get those quick wins going back to what you asked a few minutes ago is to learn
 address to learn tools and use those effectively to get over the things not to use them blindly but to use them but I don't recommend graduating immediately to Frameworks because I think that that skips far too much of the fundamental Foundation of learning
 I want to get into talking about some of the richness of JavaScript the debt you have really devoted to a large portion of your career to delving into your right that a full-scale production JavaScript off and barely scratches the surface of what the language can do what what are the aspects of JavaScript that are not utilized as often or as thoroughly as they could be that's a great question first I'd say there are there's a category of things that are used and are not articulated or understood so in that first category the most obvious
 I think to be included would be the closure system understanding the full aspect of what closure means and how it plays out and all of its didn't different facets most people use closure all day everyday and have no idea that they are doing so so that is one category of things I think there's an awful lot in JavaScript that people don't there are several other things that belong in the other category with your things that are 1 not understood and to not used because they're not understood and I would have to that I would put in that category the first again a little bit controversial I'm not I'm not it's not common that people will be proponents of the type system and the coercion system in JavaScript I'm actually a big proponent of it I recommend learning it and understanding it and using it more effective to make to create more effective and more readable code so I don't buy all of the
 arguments that it makes bad cold and it's a flaw and should be avoided all that I think all that's that comes from a lack of understanding not from an abundance of understanding but the other mechanism that I would say which I think is completely Miss used and therefore underutilized as a result as the Prototype system this is an angel to be around JavaScript about does JavaScript have classes and if it does what does it look like and we really didn't do ourselves any favors in that discussion by adding a keyword called class because the actual practice of it wasn't to implement what is the classical understanding of foxes and by classical I don't mean every single language is exactly the same I do understand that there are many different theories on class but most of all rappers that come to JavaScript do end up coming to JavaScript through one of a few kind of I would say Gateway languages C plus plus
 Sun Java being two of the biggest + C + + + Java there's a pretty clear understanding of what class means and what inheritance means and what polymorphism means and those sorts of things and JavaScript implementation of that is very different it's not just a little bit different it is polar opposite and I've spent an entire book in the series the addition of the creditors but making the case that they're completely opposite systems that's not that prototypes or JavaScript sort of bastardized version of classes in fact the Prototype system embodies an entirely different design pattern the classes and that design pattern has a name that's something I made up there's a Wikipedia page for it as a name and that name is delegation and I think we have spent the last 20 some odd years of JavaScript so and Amber Heard with the notion and the design pattern of classes that we keep layering on more and more syntax and more and more Library
 the more more Frameworks and more and more new sometimes to try to convince ourselves and lie to ourselves that what we're doing is classes in Java screen and we have completely missed out on the fact that there's all this power in the delegation pattern there's an observation that is made not unique to me but I'll simply quote it an observation that is made if you compare a delegation versus inheritance some people say those are just two sides of the same coin I think they're entirely different it's like a coin in an apple but the comparison that's been made or that's been observed about this is that delegation is a more powerful design pattern and construct then inheritance and the the basis for that assertion is that you can Implement an inheritance system in a delegation capable language but you cannot do the reverse you cannot Implement delegation in an inheritance based language
 what script is a delegation based language it's a prototype delegation base language it's one of only two languages that I'm aware of the actually allows you to create objects without classes the other one being blew up and I think we've been drunk on this notion of classes for far too long and missing out on all the power that we could Embrace if we really understood prototypes and implemented the delegation Pottermore
 very interesting thing you talk about in some of your material is concurrency to currency in JavaScript is a topic that could get us closer to some other elements of the richness of JavaScript that I'd love to discuss with you first could you define the difference between concurrency and parallelism and how that applies to JavaScript great and those that listen to me know that kind of one of my pet obsessions over the last several years and I don't see it changing anytime soon has been trying to wrap my head around the effective teaching an application of asynchronous programming so I think it behooves us to go back to some of the fundamental concepts before we were talking about the syntax in one of the most fundamental of those Concepts is this distinction that I think should exist between what concurrency means and what parallelism means it's not the bay
 are two different things it is that a parallelism is a type of concurrency it is only one type of concurrency so it's understand that we have to understand first currency of concurrency most simply defined in my opinion is that two or more sets of operations are being processed in the same period of time for example you could be making an Ajax request and response and you could be scrolling the page and repainting the position of the visible page those are two sets of operations at a multiple-step some of them are synchronous many of them are asynchronous and those are progressing at the same time if they weren't if you had to literally block then you would have a blocking Ajax request and response it would take several seconds and you couldn't scroll the page while that was happening and many people probably aren't you notice at least some people are
 old enough to remember synchronous Ajax request where it literally locked up the browser okay so that would be the definition of anti-concurrent if you had one task the completely hijacked everything and nothing else could happen at the same time concurrency means that A and B and the steps of A and B are interleaving themselves over the same period of time turtle ilysm is a way to model concurrency and parallelism literally says at any given instant not a period of time but an instant to thing two or more things are happening at that exact same moment the way parallelism is modeled in parallel capable languages is most commonly threads and you can think of a thread physically as being represented by The Corrs and your computer but we only have 8 maybe 16 if you're super looking so that's not nearly enough it's actually what's implemented is this thread pool at the virtual level at the operating
 I'm level 3 of thousands of threads that are available and your operating system will make sure that any two sets of operations happening on a thread are scheduled in such a way that they are as parallel as physically possible on the machine so you can treat them as being parallel so in other words parallelism is a specific kind of concurrency there's another kind of concurrency which is the one that Us in the JavaScript will know so much and that's a synchrony or it's often referred to by its actual implementation name event Loop concurrency in the event loop it's single-threaded so you just have one set of operations and anybody that wants to do something has to get at the end of the line and wait for their turn and so we're spinning things up and taking something off of the event lucu Opera processing it and then when it's finished going back to the event Loop and getting the next one just simply take a while truly but just spins
 the reason why that's a model for concurrency is because you can take each one of those higher-level tasks and break them down into multiple non-blocking asynchronous tasks meaning that instead of saying something like request and wait for a response you have for 5 or 10 different steps and you only do the first one and then the second one gets put at the end of the key whenever the first one finishes and the third one gets but at the end of the key whenever the second one finishes so one big task is broken down into many tiny pieces and if all the big tasks of your system are broken up a equivalently they all interleave themselves on that single event queue so that over the same period of time it appears as if you're making an Ajax request and response at the same time as growing a page so to sum it all up we have concurrency at the top it is two or more things happening the same. Of time parallelism means at any given instant two things are happening asynchrony means at any given instant only one
 it's happening but we can have lots and lots of small little things happening and spawning off their separate steps
 Shopper Engineers are always looking to automate their work software automation let us get more done with the same number of resources investment automation works the same way wealthfront is an automated investment service that relies solely on software to acquire and manage client accounts traditional Investment Services have many humans in the loop advise clients and taking fees the problem with these older advisory Services is that the advice that the services are applying is often so systemic that a computer could give the same answer or an even better answer wealthfront takes a new approach with software-driven automated investment that provides better returns through software engineering Go to wellsfargo.com / SE daily to get a special offer for our listeners $15,000 managed for free when you open your account don't pay commissions and account fees maximum
 your games with wealthfront set-it-and-forget-it investment automation check out well front.com SE daily it would support software engineering daily and it would also introduce you to the world of automated investment so you can see if you like it or not wealthfront.com SE daily thanks to wealthfront for sponsoring the show you've been a loyal sponsor we really appreciate it now let's get on with the show
 and when we're talking about asynchrony work a synchronous JavaScript programming we are often using promises and A promise is a representation of a future value show this means that if we use promises we have to be able to reason about the behavior of our code around a future value how do we take advantage of these time independent value is called promises a question to answer that I have to have to go back to this concept of concurrency and say at concurrency is actually perhaps the easiest thing in all of programming to do and that will sound strange to most listeners but what I mean by that is it's incredibly easy to fire off two different things that can happen at the same time what's difficult what's really challenging is coordinating the responses to those things if those things are not into pain
 if they're completely independent then who cares what order they finish in I'll just fire off both of them and then go on about my day but if there is some sort of dependency like if Step2 has to happen after step one for some particular reason we have to coordinate and as soon as we have to coordinate concurrency that's when we need programming patterns to help us threads are a programming pattern for that in threaded languages that's why we have new texts and semaphores and shared resource locking and all that sort of stuff because we don't have threads and JavaScript at least not yet we don't have to worry about that sort of programming class but we do need other tasks the most basic of those is to call back which is a way to wrap up the next set of operations and put it in a function and then say do this thing later continue my program later at this point but we are realizing quickly that if JavaScript is going to stick around for the next one
 we're going to need a lot more sophisticated tools to model the the coordination of concurrent operations the first of those tools is the promise and the promise is a way to put a container around a value that value being not necessarily ready yet so my metaphor is like ordering a cheeseburger at the counter when you pay for the cheeseburger it's not ready yet they give you a receipt with an order number on it and that receipt represents a placeholder for your future cheeseburger you can start to reason about and think about n even dream about and salivate about your cheeseburger but you don't have it yet so it's a placeholder and eventually you will trade that receipt with that order number on it for your actual cheeseburger but you don't want to reason differently about the cheeseburger based upon whether it's here
 or not that is really hard that involves reasoning about time and I like to say that time is the most complex state in any of our application so we can take programming patterns that take the time component of State out of the equation that factor it out hide it abstract it whatever then we make our code easier to reason about and that's exactly what I promise should be thought of as is a putting a rocker around a value which means that I'm going to interact with that rapper exactly the same regardless of whether the value was here yet or not I'm going to interact with it exactly the same I don't have to worry about that time component now that I have this value wrapped around it this is inspired from other languages like for example see which has a thing called Futures they're not even rappers they literally are the actual primitive value itself as though it has a state that it can be represented where it's not here yet
 it doesn't matter you can still add two Futures together and you get back another future that represents the addition once those are there so promises were just the way that we modeled this in JavaScript removing time is the first step in being able to reason about much more complex much more concurrent systems that have these these time in dependencies between getting to that area where we can reason about are asynchronous code
 we have generators also generators and Promises can be used together to give us synchronous looking code and it's still a synchronous in reality explain what that mean how does that work in why are generators so useful in concert with promises that there's two ways of looking at the synchronous looking a sink world the more common of the two that most people listening Williford of is the syntax is coming to JavaScript eventually called async-await there's another way of modeling the same interaction that async-await gives us which is what you're referring to its generators and I prefer that one I just actually recently wrote a two-part blog post about why I prefer the more bassline generators approach but essentially what it boils down to is this it's a special kind of function that behaves differently both generators and async-await there
 depends if functions that that behave differently than normal functions and the specific difference is that a normal function once it starts running it always runs until it's finished it never pauses in the middle it will run and it will either finished or have some sort of error and it won't finish it all but it's called the run to completion Symantec generators and async-await functions do not have a run to completion Symantec required they are allowed to pause themselves in the middle and the way they pause is there a special key word in the generators world that key word is the yield keyboard in the async-await Mason functions world that key word is a wait either way when you put that key word on some portion of a statement you're telling that function pause yourself for a moment while some other stuff in the background goes about and by pause we mean literally just the local execution of that function
 the bigger program so we're not blocking the whole thing but just that line of code is going to pause and everything after it in that function is going to wait to to proceed until we resume in the generators world we specifically resume by calling a. Next method on an iterator to start back up the generator in the async-await world that whole resume thing is built into the engine so you don't need you don't need to implement that logic to do that but in both cases what you do is say I have a promise that represents a future value but I need to do something synchronously with that value and so I need to have this little piece of my code wait for that value to come back to actually be physically present before I can go on cuz I have the plus operator and it only works with numbers and so I got to wait for the number so either with the yield keyword or if you wait. We're giving it a promise and saying
 play function I want you to pause until that promise finishes once it does give me that value back and then I'll proceed so inside of our generator or inside of our await async await function we can write things like x equals yield and then some function call and even though that function call is asynchronous not statement will pause and wait until it finishes and then do the assignment so it gives us back synchronous looking code even though under the covers it's asynchronous and the reason why this is so important is because it does exactly what I just said with promises it takes the time component and factors it out of what we have to think about giving us code that works more naturally like are sequential Brands teaching people what are the conceptual problems that people have with internalizing promises and generators and how this program
 model works the biggest problem that people have is there so stuck on call backs and they're so stuck on not really understanding why call Baxter a problem so the first thing I do when I teach asynchronous programming is I point out that this notion of callback hell that many people have heard of virtually everyone that just heard me use that phrase what concert in your mind was deeply nested indented code nested functions and set of functions inside of functions it turns out that call back hell has almost nothing to do with nesting and indentation the way a lot of people think in fact there's like call back hell.com that makes the case that it's all about nesting an indentation I know the guy that made that website I think he's brilliant and awesome but I just completely disagree with them that it has anything to do with that instead call back hell is two fundamental problems that we've already kind of touched on the solute
 to both of those but the the First Fundamental problem is that call backs are not trustable which means when you take a call back and pass it somewhere else you're not in control of how that's going to be executed or how often you made only wanted to be called once and might be expecting for it's only be called once but the calling code and you pass it to gets to decide they can call it as many times as you want or never so there's a trust ability component to call backs we lose that trust ability and that's called inversion-of-control the second problem with callbacks is that they are not linearly flowing through our code the steps don't literally flow through the code except that's our brains work our brains are linear and sequential in nature in terms of how we plan so callbacks fundamentally don't work the way our Brain Stew
 and aren't rustable and if you can't trust the code then you can never reason about it being correct there is no one solution to both of those problems but there are two independent solutions that compose well promises are a trust system so they saw the trustability problem call backs and the generator or the async-await pattern which of those flavors you like solve the linear sequential reasoning problem and if you put those two together you now have a much more effective Baseline for thinking about asynchronous programming now should say the Baseline because it's really important what I'm cleaning is that understanding promises and understanding how to either work with him and generators or in a single wait function I called that level the new Baseline competency for asynchronous pergament call backs were the original one with now Advanced to wear
 have to all get to that point that we can fully understand what that means and why that's useful but that's not the end that's just the new Baseline there's a whole bunch of other stuff that are programs do that needs lots more higher level more capable patterns for example got to get to observe also good Segway so I'll promise represents a single value and that works whenever you're making a single action in you're expecting a single sort of result back all at the same time but there are many things in our program that we do that are for example of single request but we're going to get back lots of results and not all of them at the same time that is more closely you know you might associate that in your mind as a stream of values for example you load up a web page and you're listening to stock ticker updates you're not going to just get one
 update you're going to get a new update every second or every minute or whatever so we can model concurrency model asynchrony when there's going to be multiple values spread out over time we can model that with a higher level of abstraction and the most common term that we use for that today is observable it's basically like a stream so if you understand stream semantics then you're probably better than 50% of the way to understanding what are no observable is but I guess the best metaphor for an observable is a spreadsheet if you think about in the old school spreadsheet more Alden maybe so many people don't do those these days but if you know what a spreadsheet how it works you put a value in cell C3 for example
 and then you have about a cell d563 that has a value like the value 10 and then D5 you can put a value in D5 or you can say the D5 is a computed cell based upon some function of the value in C3 she might say the D5 is c 3 times to so whatever's in C3 double it and make that the value of Define well at the moment then you're going to see 10 + 20 + that's super easy and then you can make another one saying E1 and that's a computation of whatever is in D5 and you could say whatever Cindy five and three to it so now we have 10 in situ or whatever nerissa C3 has 10 D5 is 20 + 81 has 23 3 and change it from 10 to 11 let's say
 I almost instantaneously faster than what we can see the other two are going to update their going to recompute because what we did by changing from 10 to 11 was putting new data into the system and that data propagated its way through that series of computations those competitions happened right away but some complications might actually take a while to do so every step could be in its own an asynchronous stop that Shane of computations were a piece of data flows from the first step to the second time from the second step to the third and so forth that's how we that's what we model when we when we wire up LEDs are verbals we create a stream of events where there's a piece set of data that's coming in and then there's some sort of operation that we're going to perform on that data and then we have stream that's coming out and then we can take the string that came out and do another operation on it and get another stream & Stream & Stream we can also take multiple streams together and start combine
 in the higher-order streams you can zip them together or merge them or in a hundred other sorts of operation but essentially what were modeling is how dateable Haynes overtime so if if for example you you think about the old school map and reduce functions that most people are probably familiar with those operations we do those are across an array and array were all the values are already present so if I'm mapping something I just know I need to nap Alton values to a new set of 10 dogs think about stream operations as the same thing that we do synchronously within a ride but there were doing asynchronously across an array that's going to get new values overtime that's basically the time and this concept of reactive programming reactive programming Paradigm programming around observables why is reactive programming gaining so much popularity today
 I think it's a mindset few things first off there's there's a whole bunch of stuff that we do in our apps that just simply can't be modeled by a promise all by itself the promise is really good at modeling single request single response it's not good at respond modeling responses overtime and are turns out our applications do you have lots of responses overtime in general so that's one of the big reasons another big reason is that it, I'm sure some of the fascination I think that we all have our many of us have with wanting to understand how functional programming practices can improve the understandability and they reasonability of our code and reactive programming take some of those some of those Core Concepts from functional programming and applies it to this world of dealing with a synchrony where we have a value inn and we don't you take the volume of create a new value out so we don't need you to stream we create a new output stream lasorsa thanks I think combining those things gives us the power to model much more complex parts of our application
 more expressively it's not that we're doing new stuff that we never did before it's that we're doing the old stuff in better ways than we ever did before
 so I want to get to close out the conversation you are from Austin which is where I grew up as well and I think of Austin this is very interesting texting that has so much potential but it's it's strange that there haven't been more big and successful tech companies out of Austin and as somebody who is also from Austin in the tech industry I'm just curious where your perspective on that is like what is the state of the tech scene in Austin that's a bigger question that's above my pay grade in some respects to answer I do have some ties to the entrepreneurial seen here in Austin and I would say maybe the best way to to summarize a really complex history of the city is to say that it's sort of that sort of a sleeper in the in that respect in terms of entrepreneurism I think Austin is where an awful lot of
 ideas start and it may not necessarily be the place where those ideas come to full fruition so we see a lot of people that come up with a great ideas and then after building them for a certain amount of time they move on to the more traditional centers like for example the Silicon Valley's where a lot of the money is more centered that doesn't mean Austin's not a destination there are many many great success stories of Austin being the destination of companies that started elsewhere and decided Austin was the right place to move and and build and grow so there are plenty of of those kinds of big success stories of companies that that have been very successful coming out of Austin I think Austin does have some challenges that have constrained entrepreneurialism specialist and political challenges I think one of the biggest things that is a problem here
 I've lived in Austin now about 15 years and in the time when I'm first move to Austin the entire greater Metroplex of Austin was about I'd say maybe around 6 or maybe seven or eight thousand people at the most for the whole Metroplex at this point the Metroplex is over 2 million so in that 15 years we've well over double approaching tripled in size and I would say that amount of growth over that rocket of a period of time we have not kept up with that politically and culturally there's been a lot of lot of that like hold on to what makes Austin going to Keep Austin Weird hold on to the small-town mentality so we have we have some challenges I mean people have probably been living in the news recently with the the latest fight in the Uber Lyft battles it doesn't look good for us that we are not able to cope with the modern the modern teams of transportation and and dude
 in a reasonable basis so there's some things like that that the challenge the city but I still believe this is the best city to be a tech person that's why I live here I've had plenty of opportunities to move elsewhere and I still think this is the best city to to to start and build stuff atmosphere Ratio or what is it exactly what do what makes it the best text City well there we have plenty of great things I as a as a teacher that travels all over the world actually get a chance to see an awful lot of the world and not just a lot of the US but I mean a lot of the whole world I've been to Australia and India and everywhere in between so I'm seeing a lot of the world and I always like getting on that last plane like to come back home to Austin there's a lot of great things you know simple things but great things about Austin we have some of the best food culture around in terms of barbecue
 breakfast tacos and other things like that were world renowned for those things one of the things that I think makes Austin great is that there is not a lot of pretension here I can sit down I go to a group every Friday morning that I'm in town I go to this this little totally informal group of folks gather at a coffee shop and I'm sure there's lots of cities that have things like this to but we call our group the regulars and all that means is that every Friday morning we show up at the same coffee shop other than that there's nothing that ties us together so there are artists and musicians and tech people and business people and who knows there's people like I don't even know how that guy makes a living it's kind of sketchy I mean that's just all kinds of different people that show up in and it's there's no advertisement it's all word-of-mouth and hey you should come and hang out with us I show up at this group on a Friday morning and I'm sitting there you know having a having a muffin and show
 with people and I could be chatting with the CEO of a huge company and have absolutely no knowledge of it because there's no pretension of social strata like well you know I'm not going to mix with the commoners people here just love to sit down share ideas talk collaborate figure stuff out you don't feel like every person that you're talking to you has an agenda like oh you know where you going to be my next investor or you know how can you benefit me it's just we kind of like being a community and sharing that stuff I would say that's probably the best answer I could give for why I've made my vote for Austin whenever I go home and yeah I don't know
 interesting wellick I'll fix your car on the shows me a great conversation touching on JavaScript introductory to advanced concepts to Austin Texas and appreciate you, the show Absolutely thinks it's been an honor being here and I am I hope more of your listeners will come check out the city and I hope more of your listeners will check out JavaScript to take them
