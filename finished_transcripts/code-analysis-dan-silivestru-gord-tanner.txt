Transcription: code analysis tools can help a developer understand code 1 tool for code analysis is bit Hound which provides code and dependency analysis for nodejs applications on today's episode we discuss how to use a code analysis tool and we also talked about how to build one by breaking down at the distributed architecture of bit hounds back-end is a really interesting episode about a product that many developers are going to be using in the future weather it's specifically bed Hound or any code analysis tool this is the type of tool that will help developers save time and avoid dependency problems in the future with the security problems all kinds of other problem if you're a fan of software engineering daily we want to know how to improve please take 5 minutes to fill out our listener survey there's a link to the survey in our newsletter and on our website we would love to know what you think we want to know which one you're more of what you on here less of and as soon
we get enough respondents we will stop hammering on the survey but we we really want to get a representative amount of data and people still haven't really filled up yet the survey many people have what we want we want more so we really want to build the best software podcast so please respond to the survey after a quick word from our sponsor we will get to this episode of software engineering daily
 as a software engineer you have tremendous leverage in the employment Market every company need software engineers and these companies are all competing for you the engineer a scarce resource but as an individual engineer you don't have much insight into this incredibly opaque Market that's where hired.com comes in her.com assigned you a talent Advocate who works to understand your needs and works to find you the perfect job go to hired.com se daily to try out the platform today and get a $2,000 bonus if you find a job the companies on hired compete for you the engineer and then make bids to win your talent these are companies like Facebook and Uber companies that we know are on The Cutting Edge of engineering because they've come on software engineering daily to talk about their Tech stack
 I have used hired personally and I've experienced firsthand the ease of finding a well-paid enjoyable job this was way better than replying to LinkedIn messages from uninformed recruiters and is also certainly better than using a job search engine to find a great job and support software engineering daily go to hired.com se daily and get a $2,000 bonus upon finding a job check it out it would support the show now let's get on with the show
 bit Hound is a tool for nodejs code analysis gourd Tanner and Dan Sylvester you are the CTO and CEO of bit Hound Gordon Dan welcome to software engineering daily if you hear about code analysis what does that term mean code analysis breaking down the software that you're looking at so taking the code bring it down and what's called a nasty or abstract syntax and and being able to crawl that and try and expose a whole bunch of insights to help developers essentially do a better job so I could be as simple as renting making sure that stylistic guys are being followed and then there's more complex things like looking for duplicate code or complexity within various code branches and expands well beyond that swell
 as developers we give off lots of data while we are writing our code and when we're working on projects and this data accumulates in GitHub repository and across our test runs and when we open and close bugs and as our data accumulates it is building latent value and I think bit Hound helps to expose some of that value so give me an idea of the value of this type of information that we are giving off as we develop applications
 Genesis of the idea for Baytown was looking at all this data that we do generate as we commit to a repositories as we comment or code as we open and close button issue tracker says we run our test says we release chakra and build software there's just a lot of data that is created as we work alone in together in on teams and come I came from the call center software industry where data is King in that industry it's all about call wait time that's all about how long people are on hold how how many people are converting to a sale from a call so taking inspiration of Diana always wondered are we at a point when we can start to use some information that we generate is developers to build better software and better soccer teams
 cool okay so you mentioned using an abstract syntax tree to evaluate a code or or other information listeners may be familiar with the abstract-syntax-tree cuz it's something that we use to build parse parse R programming languages so that we can evaluate them and and actually run code give me an idea of how how the Baytown product actually works like what what kind of what kind of work you're doing when you build an abstract syntax tree for somebody's code and what your assessing when you evaluate that syntax tree so it goes well beyond just pushing vsd210 information at the Lord mentioned before it terms of the amount of data does generated and thinking but no choice to think of the code also in a historic sites right so far seeing the SD allows us to
 you look for blemishes in the code itself or you know structure issues it's much easier way to find things like the code and complexity but then coupling that information with the historic information that we get units generated by all of these developers and the teams that surround us allows the started signing fragility scores to files basically how I know they touched you know for what reason are they being done for how many in a bug fixes are there versus actual work that's being done so given us kind of bug grown measure of the files and when you take that in your couple it with the blemishes in the code you can start assigning your better severity scores on whether not something needs to be addressed based on how do we think about no JS JavaScript code versus a language like Java I think of
 Java is a language that is better at catching your errors and Java would be perhaps a language that is it no not accurate
 okay yeah just cuz you know exception-handling and what not how does that contrast with with with JavaScript and why does it give rise to a need for a tool like a bit Hound
 well JavaScript and I mean I love the language known as well there are probably a thousand different ways to write and there's good ways there's bad way is that a good parts and the bad parts and O's do you continue to evolve at the language of South of Olives design in roughly 10 to 11 days and I think we one of the core needs for it was because the expected to have developers coming from all walks of life and all different past experiences may need to be able to be written in various flavors of someone who's coming from like the Sea World of the job of world could actually relate to the language and so and the language itself is is dynamic right it's not start if your pipes there are a lot of very simple mistakes that you can make such as the typos and a variable name and the language won't stop you from doing that it will just make that thing Global and
 you keep running which could result in some very interesting bugs and and you know issues down the road so I think would JavaScript there's much more of a monitoring and do you need for a conforming to standards and having these kinds of continuous checks on your code because very simple mistakes you know it being a non compiled language interpreter language makes it such that you will catch those issues but you won't touch them until run time which is probably you know in the scale of where is your highest cost to catch a problem no its production then it runtime you know when the cheapest one is one of the doctors actually actively typing at the keyboard
 show we're talking about code analysis in the abstract and a subset of code analysis is dependency analysis why is dependency analysis so important in the projects something Wheaties known as Beados deeper into working on been around as well as what our customers were needing we thought originally Charlie on Lind code style like static code analysis but as we were working with our project work with other people's project which I did notice that the need to keep track of dependencies was a problem that we were having that everyone else was having the note ecosystem is an amazing place where there are literally thousands and thousands of different third-party components you can use to build up your project and keeping keeping tabs on them is quite
 not sure that sometimes gets put off of the side as you're focusing on other issues and so as we were writing bit handwriting the dependency mouses for bit how we found we were able to give our customers and our users the ability to have someone else watch watch that for them so they can focus on more important things and have that ability to watch the dependencies for when they go out of date when they have potential security advisories when they're deprecated or other or they even start the unused we give them the tools to detect I haven't you update according
 let's get into the usage of bit Hound so let's say I am I am getting started with a project and I want to use Bed Head like let's say I am I'm the developer of angularjs or gulp JS attic these are both projects that use bit Hound but let's say I'm just getting started with one of these projects and I'm like okay I want to get started with bit Hound I want this code analysis sweet of tools how do I get started and what is the onboarding process like to keep it as simple as possible and having to configure a product before you even get a chance to get started with it is quite a chore so really you sign in or sign up for been around using up at Buckhead or get a stripper to Angels you off in your instantly presented with the list of all of your projects private and public all you literally have to do is click the Big Green
 that says add the project we instantly kickoff analysis on it we try and what books so that we are aware of every new commit that comes in and we integrate with your VR process so that as development could you stop in and pull requests are being issued by your developers been on compassvale those poor request based on your criteria so that's what it takes to just get started and then very quickly afterwards you could do you know One Click at slack integration I will have a CLI so you can integrate with your old system in case you want start feeling your bills should say that security vulnerability be detected on one who dependencies or you know if complexity goes beyond a certain critical point
 you've mentioned these other code analysis tools like linters so as we're discussing kind of a used case of somebody getting started with bit Hound compare their experience with bit Hound what that would look like vs. how they would experience older tools like linters or or or whatever it whatever other tools you're seeing people compared compared to town to absolutely so I mean you know what I think we actually have linters implemented and configured for their local development environment what sound does is it takes all of these analysis results and merge them together and then augments them with other insights and other analysis that we do such as intended for agility of certain files you know whether or not they're bug grown and the amount of work that happens on the normally and what
 driving you having to go to 5 different places or integrate multiple command line calls into your your C or your local environment and making sure that all of your developers have it all configure the exact same way I've been on provides you with an instant dashboard that highlights the things are most important for your team to address so essentially generators priority items that means that you really should be looking give you recommendations on how to fix them and then beyond I would have said integrate into your workflow so that essentially your team and yourself can continue to focus on what's really important which is your features your type that lines and allow been around too much to be your security blanket and making sure that entire team is living to the same standards and the same Styles and isn't getting in trouble by accidentally shipping something that could put your your product in your company at risk due to some security advisor your Bonneville EXs
 what we provide is context because we're running more than just the way we running more than just like your standard run-of-the-mill analysis we take all of these data points at work and bring them together for context as to what like Dan said what is most important what you need to look at what dependency is currently the one you should focus on which is just that's what we can provide doing all the analysis in bundling together which is quite hard with the the standard tool stack what's an inner typical workflow when are people signing actionable information with bit had to sit like I write some code I ship it to the repository repository in Like Mike continuous integration tool kicks off and then bit Hound is somewhere in the in the continuous integration tests or how does that work exactly
 I've been out exactly sitting quite a bit closer to the developer than that right so every time I come it goes in Ben Hur goes to work on it trying to finalize it and then provides valid results and if anything is found then you slack message goes out or if it developer tennis shoe for request and we set pass or fail it at the same time the developers might not have done anything for the past week but a new security vulnerability might have been detected on one of the penalties that they have so been Hound will proactively alert that the developer in the entire team through either an email or a message into your slide for hipchat to to alert you to the fact that you are now it's supposed to do to a vulnerability hired as a developer you know you're writing software but the the velocity at which software engineering is changing just the end
 I meant around it and the velocity of which security vulnerabilities get discovered that out that is all increasing so it's just like this layer where it's constantly sniffing out problems that could occur you could almost think of them as like a metagame changes that are occurring in this software development ecosystem point in time where there's more software being written it's more complex it being written faster and at volumes which we were unprecedented even a few years ago so we're hitting that infection point where it's getting the point where are you
 you have to analyze software software the human cost and brain space of keeping on odds of all this is trying to approach an unmanageable level and that's where I services like it how nuts what word jumping into provide the ability to alleviate some of that pressure you have on your already full day to keep on tabs of all this like information coming at you that's right and if I might add to that the weekend to think of our development team is being made up of our core developers and you know our team members themselves right so if one example of team of fiber 2004 of the people that are in building code but if you taking proper advantage of npm and all of these external third-party open source modules write your team is actually potentially made up of hundreds if not thousands of people a lot of what you have in bed it and all hard hard at work at getting those components to you know continue to evolve and fixing bugs and performance issue
 all those kinds of things you know we no longer have the ability to as individuals keep tabs on all of that without automating the process and somewhere and fashion
 so now that we have an interesting idea of how bit Hound works I want to talk through a engineering problem that you guys have dealt with it bit Hound so in order to understand the health of an individual project you might have to do analysis on thousands of of commits to a project and so there's so many things to look at so bit Hound servers are running and they're trying to analyze all these different projects the analysis of thousands and thousands of describe the the challenges that are associated with this problem I had a strong knowledge that this was going to be a Distributive problem we couldn't
 sitting one process and monitor every commit that's coming in on every file there's just does a CPU cost of the time cause there's an IO cost that is involved for analyzing this is we all know if we run we run our bills we run our test we clone repositories we run went on the we know there's there's time you can feel that in your own environment as you're working so stealing that up to the scale of which we are where were analyzing thousands upon thousands of projects a day like hundreds of thousands lines of code you can imagine that you can't do that in one process so from day one when we broke out into a distribution model to have all of our task speed defined in the smaller works at so we can send out to random workers
 describe the the concurrency Model A Little More the distributed model like what was the granularity of of concurrency and and how did you distribute that work in currency there are few ways to do concurrent see there is the traditional shared memory model where you take some physical location on computer in memory of Ram or even all your processes work together sharing thinking of passing the butter dish on your kitchen table it gets kind of tricky when someone tries to grab the butter dish before work someone else is done with it so that usually is a more complicated way to handle concurrence and you can end up with what are known as Deadlox or likes some other similar cases now another case which we actually went with which no work really well was message passing where rather than passing the butter dish you
 past messages about the state of the butter dish so you can say well I see you starting to break down horribly but messages and information about that item that people can do with what they will so there's no once I send a message out into the into the world it I don't care what happens that message anymore I'm not sharing something physical I'm sharing information
 okay so you went with the message passing model how did that fit around this this problem statement of analyzing thousands of commits
 it works quite well the first there was a small problem because obviously there is a butter dish in the way of your repository like we have to clone that somewhere we have to have physically located somewhere on desk so that was that was kind of an initial issue so but we all believe once we had that in place it's just a matter of we will build our messages about files every want to look at or an ounce is going to run into send those out and works really well with no because of a super easy Network stack we chose zeromq as a base messaging layer that allowed us to build a pretty flexible Network and not worry about a lot of that networking hiccups eyes Okay the server has to be out before the client connects or what happens if we lose connection all that was handled under the hood for us so we could just essentially is easy it is to write to a note
 centimeter and node we can just Spire events transparently in our code and for all I know it could be handled in my process in a process next to me controlled by a shared cluster manager or in a completely different data center a completely different machine
 so can you contrast that with the how you would apply a message passing solution if you were working in golang or erlang or one of these other languages that we hear more closely associated with with message passing architectures
 yeah a lot of those languages have a much more expressive concurrency set of Primitives that you have available Nick JavaScript thread so you're only ever doing one thing where somebody's other languages do shared memories shared State a little more expressiveness around when you lock things when you don't lock things and I go Let Go With It Go routines has a really beautiful expressive way of the dealing with subroutines and sub processes in message passing between them so everything which has its pros and cons I think what we got from JavaScript in node was
 lack of choice almost I don't want to say we we had kind of call backs and asynchronous I owe any kind of lived in that small small straight box to on how we can communicate bills are good as a great opportunity to join the fun but dog food are on product right because we're fully built in JavaScript and allowed us to really put been Hound as a product through its paces and make sure that we're building something that is providing value in his worthwhile for us and that we could never use on a daily basis
 and not to mention there are good reasons for just using note otherwise like you said note is a great language for glue code almost like Pearl and some ways like show what types of glue code what types of scripting tasks do you find yourself using from node we've gone with the idea that
 failure is almost the normal rather than the exception because we're dealing with hundreds of processes running across hundreds of machines machines are going to die that networks going to pick up the disk space going to run out that all these exceptional cases that you could run on like your standard install end up being not so exceptional so with the idea of glue code a lot of our tasks are essentially node processes that are wrapped in an easy to use command line that we stream together on Via shell scripting or via other node processes so it just work really well with the concept of the Unix style small tools where you have standard and you have standard out she was just passing information between them and you can build it in a way that one part failing doesn't cause the rest of your tool chain to fail out and the lack of having state
 with each one of these processes means that if they do die and we never hear back from them it just get to reach you and they start working again and it's just an essentially self recovers
 so in order to architect this distributed problem you built a master-slave architecture describe how that master-slave architecture works and maybe if you could give a small example of it over you've got a thousand years but you got a bunch of get Hub repository as you got a bunch of commits to evaluate on this architecture how would the world be distributed among this Master Slave architecture in this controller would start off figure out how many 10 minutes are in this country clone it down figure out all the files that we would need to look at and then send out those other jobs off to my worker processes
 so there's never this concept of
 Master controller process anymore that every single process needed to be able to spawn subprocesses back in the cluster to do their job so for an arcade you still like a hierarchy there is no hierarchy actually it's kind of a giant mesh Style Network where you anyone in the network and just send out a message and or group messages and have them all be protested processed and sent back so for example in our case of analyze repository for a step clone it breaking into the commit sin. Each come it out into a message I can make him then further be turned into specific file and so on and so forth and it's a delicate balance of finding the granularity of the messages and toss you want to work on versus the distribution of them cuz sometimes it's just faster to iterate over a list of
 2005 rather than breaking them to both groups of 50 and distributing them it's kind of work with us you're playing with distributed systems sure and for the system you built a module called farm that is open source tell me about Farm East messaging they are we have in all of our worker processes said it was an easy-to-use kind of DSL around the sockets of you and sending it all up is more of a thought exercise of Open Source it up just so we can talk about what we do is we we can look at it see the examples I know we're using a heavily I'm not sure if anyone else is but yeah it was just the ability to
 how's that common module that all our processes can use and our other team members don't need to spend more time that I do thinking about our Network architecture or how to like send these messages or what happens when one of them dies it's a nice way and the one of the cool things that came out of it was the idea of our Global event publish-subscribe system that was really interesting cuz we're all familiar with the event emitter in Noah breaking publishing subscribe messages in your process in which we built that into a global publishing scribes for every single service and process in our entire network can publish And subscribe messages across all machines are like analytics monitoring the kind of keep stats State on the system that kind of go KY work today or what have a command
 call census which we will fire I will send a command line senses and it sends a message out to every single process and just ask them to fill out some information to report back on like this is what I'm currently working on this is how many things I've done and we have a long-form census result to comes back from every single worker that is currently in the system we can use for tuning or discovering workers that could potentially in a condition where we need to restart them
 when you launched bit Hound initially you went from having your distributed environment running on a laptop to a disturbed environment running across hundreds of boxes describe the difference between bit how does it work locally and what happened when you lost it to production with the thought of distribution I member it was the first GS concrete kind of came in and sponsored and we made a few assumptions about state so that that repository clone for example like when we were working on your code we don't keep any of your code meditate about it's the Kona repository analyze all the metadata and delete it and the sand as we are working on this year like always think on this and all the other processes
 is there a proposal tree currently existing somewhere I can access yes if not I'll recall on it so if you imagine a repository coming in on at your local machine you quoted once you have 10 workers that are all on the same machine all 10 of those can do the easy are both already exist I don't need to recone it when you're going across hundreds of machines I wish we were for our production environment in chess, diet case of shared state which we had we assume that works nicely but I'll send every single project with clone hundreds of times which you don't really get to experience until you start actually Distributing the code
 certainly interesting story another thing I've heard you mention is that you use vagrant to bridge the gap between your Deb and prod environments and we have the founder of hashicorp coming on the show in a couple weeks so I'd love to hear more about vagrant like how does it how do you use it how does it bridge the gap between your Devin prod environments what bagger gave us so for those people are disappearing is termed a great is a simple way to build & provision virtual machines on your local Dev environment so you can Define in a simple file like three four different machines their rules and subscripts to run to provision them so the way we use vagrant is rather than developing on are on are MacBooks or are mixed up machines we use baggage create 3 to 4 virtual machines that are then running the same OS as our production environment
 in the same configuration using the same scripts is when we're starting up a new instance in the cloud or on there we will run those same scripts over and over as we start up these virtual environments locally. Gave us a local environment running the Buy proxies in front the same as a cell the same load balancers the same situation where you have multiple workers that have been provisioned a certain way and it allowed us to hide all that from our developers who are designer front end developers upstairs can still work in an environment that is exactly like production on a smaller scale without having to spend their time realizing that allow remote connections needs a couple weird tweaks on the whole idea was simplifying the onboarding process for new developers and existing developers and for keeping the parity between
 production and local development so that we're less surprised about how certain architectures work in the real world
 I'd love to talk a little bit more about the product high-level show currently you're focused on nodejs do you do plan to expand Baytown to other languages expanding been Hound Beyond know Jess is definitely on the road map we made an internal commitment to go with ourselves and our customers that we're going to continue to dive into nodejs in JavaScript to really be able to provide an exposed very deep insights into what's going on in a quart Dutch done it before but it just it's not just static analysis inside of a dashboard but it's really being able to Divine enough information to provide context around the results that we provide so that you know the developers all the way through the project managers and ctOS can actually drive decisions and be assigned work based on the context surrounding the results so once a week you feel Oromo
 Sarah this point with Ben Hound there's a couple more places to dive into but then yes other languages are definitely are.
 Do you see a light at the end of the tunnel in terms of the note JS work like it it or is it like where you you implement one thing and you see 5 more things you need to do I definitely think it's the ladder and it's not to say that you know I've been slacking but the environment the language and noted self and you know what that all of the things are associated with it such as npm I continue to move forward at a break next Pace right so you know JavaScript as a languages evolved year of a year with new implementations you know what a new language features I get implemented in me to make sure we stay on top of those as the whole ecosystem matures and has no it has truly become Enterprise ready you know there are other considerations that that go with that everything from long-term support to know just better practices and things will happen
 all this is massive amounts of third-party code that you know we're consuming on a daily basis so I think if we did nothing but no support we definitely still have our work cut out for us for the next few years for sure I just because of the speed at which the industry itself is moving
 we should have put the first but the hardest part of first like you know that I imagine once you get nodejs right you can I get the Flywheel spinning then you can be like okay well let's go hire a ruby expert and then we can have some of that does the real stuff in Ruby as fastest moving I get the sense it's moving slower than the no JS community so presuming that you have the best practices in place from the nodejs implementation you know you can do that you'll be able to do the ruby-on-rails implementation much more easily be honest it going to things that we've realize it was really diving into this level of analysis is that a large percentage of the analysis they do and to be able to gain the right contacts in terms of the Inside Story provide to a customer so they can take so they can know what actions to take this is the actionable insights are actually language-agnostic right like looking at a file
 see you know how heavy is the churn on it whether or not it's a bug prone looking at it dependencies and where they're being used and what does that mean from an impact your project when we recommend that you upgrade up to codependency because your security vulnerability right if its use in one place and maybe you're lucky maybe it's a five minute update if it's using a hundred places and you more than two versions behind rest is breaking changes there in a whole lot touchpoints maybe that's a week-long exercise so I think we wanted to make sure that we implemented you know that kind of depth of analysis inside been out knowing full well the lot of it is language-agnostic cuz that would give us an opportunity to later move on to other languages with the same depth of insight in a relatively short time span
 you mentioned the term of bug prone how do you how do you identify a bug proneness in a line of code or a repository magic know there's there's a lot of contacts that we add as we are working on projects right now it's just a kind of a little bit of like Words stemming matching on Commit messages Tracy math what issues are open and closed versus sentiment analysis of commit messages we we can kind of determine usually when you're fixing something versus adding a feature it's and then just using that in the context of all your projects and all your commits and all your files you can kind of cheese out of the language of the team with use to determine what they're fixing something first if they're adding or tuning something
 so what are the biggest challenges that you guys are working on at Baytown right now
 I think one of the biggest challenges obviously you just keeping up with the industry and the pace of which it's moving but I think our biggest challenge is it is a company would you continue to work on is providing that context that we talked about right it's essentially trying to get been around as a service and as a software program to try and perform the same job as you would expect the senior developer coming into a project looking over the code looking over the history checking out the blame to really understand what needs to be teased when he's to be changed to get the project Hino really moving forward smoothly so the biggest challenge is really getting getting bit Hound to work and act like a valued member of your team and terms of the inside the context that wraps around that rather than just being a dashboard with some you know some numbers and and some alerts did not say that's probably the hardest part is trying to get
 been out to to act as a human software developer and its analysis
 I would love to get some insight into the business because of the business of bit Hound also like how do developers know that they want this tool or do you have to put in front of them and say hey this is an awesome thing use it
 I think the answer is a little bit of both so we know we talked to quite a few senior developers and and you know working ciccio's and vpns right where the actual stone coating & for them been Hound serves the initial function of a validation of a gut feel like I always knew I knew that was a problem now I have an objective third-party telling me about it and give them the added benefit of being able to align their entire team to deliver to the same standards and you know making sure that the more junior members of the team are aware of the impact of various actions are they take such as wish dependencies do I include at what stayed know what does your latching onto a deprecated dependency mean for a minute. The other end of the spectrum we had to go up there so I can just checking behind out not really sure what it is all about and then using it as a guy to improve themselves
 what is developers because we expose things that no one even when you're first starting out in this profession not too many Schools teacher about and so there are some that we need to show the advantage of been around too but once they see it I think it becomes quite clear and it gets very engaged and then there's others that enough told us that they've been been looking for it to like they hang out for a while knowing that there was a gap in the development process and dirty mechanic
 you guys bootstrap or did you raise money or what's the foundational story we raise money for for the startup we we start off with the intent of bootstrapping but we had had a successful exit prior to this rebuilt the company called tiny hippos which was acquired by blackberry and as we went through talking to investors early on which if there's any startups out there listening please do that from day one of your company and so that way you have a story that continues to evolve with your investors yes you talk to investors before even even before you're actually ready to retire absolutely because that way by the time you are ready to raise money they already have a graph plot of a story line that it can mean onto and they're not just getting to invest in lines not dots
 had a bunch of very early commitments to invest right off the bat part of it was our historical success others just they they really loved the idea and have personally felt the pain at some point during their careers the Ben I was trying to solve and so yeah we we did raise two small seed rounds to get us to where we are today
 cool so what's in the future if it happened to be that expensive oral solution and framework for companies to manage their entire software development process so not just looking at the code and what is an individual commits the developers are doing but really helping you manage everything from the very beginning of a project all the way through to deployment and continuous deployment and be able to give you deep inside it's not just into the code but into the kittens of your team performance what areas need to be improved and nearest how can you better manage this offer delivery process within your organization
 you know okay what one thing that that has been coming up at an increasing frequency on this show is the the build vs. buy debate is becoming really interesting because there are there just like it is going so fast that there are just so many cool so you can buy that will improve your process and it becomes this trade-off of like are you willing are you literally are you willing to pay some money to solve this problem quickly so that you don't have this problem anymore and it seems like it's it's in really is this Evolution how software engineering is taking place where you can just buy these components and they just do what you need them to do do you guys get that sense also or is this kind of a trend that I'm imagining
 bird like they're trying it out and we are passing well why don't you by U2 Burton gives you credit card start paying us in and the CTO of a startup and I don't know what I'm going to do this myself I can I didn't run a few scripts I'm going to spend put them I see I only need this summer like I said okay well
 work $59 a month to lowest tier which the cheer you are at if you were to pay
 how much time is it going to spend you to build and manage this system that would do a good Hound does like and what is your hourly exactly is your hourly rate like less than a dollar a day for your Developer Edition maybe yeah you can save some money but the reality is is
 you sometimes forget that sending two three four of your developers for a week half project to build an amazing code analytics solution cost you a lot of money and you're probably after that week you spent enough to have a 5 year subscription from exactly on top of that there is a lot of effort involved with keeping up with the evolution of the language and you know everything else that goes with that I'm so think a lot of our customers are finding that it is remarkably more cost effective to just engage with a service like Big Ben sound rather than building an eternally and we have talked to several companies and we've had some Comforts way so yeah we used to have our own set of command line tools to to attempt to do a bit Hunters doing and it was constant maintenance and just be updating all these mpm components but switching over to Fitbit how I met just clicking a green button and then a blue button and then we would
 I imagine many of your customers are startups technology companies and there is this there's a strange narrative in the business landscape these days that it is risky to be a business that is built on startups selling to other startups and I think that this this this near how to get overblown and gets misinterpreted but I'm curious to see I'm curious if you guys interpret that is like any sort of risk to the business or you know how legitimate you think that serve narrative is like oh where where do for this downturn that is going to lead to all these startup selling to startups crumpling to resolve to really understand not just a market Landscaping the competitive landscape but who your customers truly are we all make assumptions early days in terms of who we think is
 going to buy a product and then as you go through and start selling it I think just like a diversified portfolio when you're investing your own money you don't want to go all in high-risk high tech stocks do you want to make sure that your product does appeal to the small to medium-sized Enterprise gets established already at a minimum Beyond just the startup world and make sure that you have a legitimate path to get to Enterprise mini the fortune 1000 companies in you know what are the the value proposition that your project and then product provide to entice the larger folks so a lot of start-up start by selling to start up with a small Enterprise because it's it's easier to do that all automated conversion to pay you don't need as much sales staff to pick up the phone calling but understanding how your product can provide value beyond the small Enterprise even though it comes with longer sale Cycles it also comes with larger dollar figures but it helps you company
 established in and survive any potential downturn in the in the solar system
 cool well that sounds like a good place to close off gourd and Dan thanks for coming on the show that's been really interesting conversation spanning code analysis and investing and all this different stuff and yeah I'll be following your product closely
