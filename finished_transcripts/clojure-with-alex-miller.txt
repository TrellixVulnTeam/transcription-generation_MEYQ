Transcription: closure is a dynamically typed a functional language that runs on the jvm today's guest Alex Miller gives us an overview of closures core functionality Alex is the developer of cognate packed and he is the founder of the strange Loop conference as well there's some great talks from the strange Loop conference if you haven't heard of strange loop on Youtube so check those out in today's episode we discuss the data structures the garbage collection strategies and the concurrency support of closure how does closure compared to other jvm-languages like Scala and groovy how to record your copy and beautiful data structures without copying all of the data how does a closure program get evaluated in converted to Java bytecode these questions and many others are discussed in this episode before we get to that it showed a few quick announcement software engineering daily Community has started working on a project called software daily we are building an open sore
news and information site about software and we've been making significant progress we are particularly looking for somebody who is familiar with react JS or nodejs in particular who wants to build the server side aspect of software daily this is an open source project that I really like Prophet designs in mind but that we just want to build a really good software engineering news and information site and you can also go to software engineering daily.com where you can find out how to become a host for software engineering daily can find the links to the slack Channel likes to my Twitter account my email you can sign up for our newsletter featuring curated content that we find throughout the week so that's it check out software daily check out software engineering daily calm and with that let's get to this episode about closure with Alex Miller
I had a crazy idea couple weeks ago it's a photo sharing app that only has pictures of cats when I finish my photo sharing Cat application I will be deploying it to linode because Leonard is the fastest hosted Lennox provider I don't want to get locked into a proprietary platform it's going to overcharge me as soon as my app gets popular I just want a fast Linux server with simple pricing go to lenovo.com SE daily and get $20 in free credit today plans start at $10 a month so my free $20 will be plenty to watch my cat photo sharing app once I need to scale I can use tools like an ode balancers and backups and Lynyrd has built-in dashboarding and metrics so that I can see the traffic to my linode servers and I can understand how many of my users are posting cat pictures and looking at each other's cat pictures go to
note. Com SE daily and get $20 in free credit today the plans start at $10 a month such a great deal thanks to linode for sponsoring a software engineering Daily Now what's going on to this episode
 Alex Miller is a developer at cognitect and the founder of the strange Loop conference Alex welcome to ShopRite new daily hello there been actually a lot of listeners who have been asking for more episodes about closure so happy to have you on to talk about closure and let's start by just saying what is closure coaches of dynamic functional language that runs on the jvm and then there's also dialects clojurescript enclosure CLR that run on well transpile JavaScript and that run on the clock on the dot net virtual machine as well and the creator of a closure is Rich hickey why did he create closure initially
 well I fix the what he wanted was something that had the the small core and flexibility of list that ran on a host that provided a lot of facilities so things like garbage collection and pipe Nino high performance over time and you know that the just-in-time compiler and things like that that also had a beautiful data structures and functional programming and good support concurrency
 bright and it seems like some of the desires he had in creating closure wore around his discontent as a Java developer and just object-oriented programming in in general I think you'd be doing a lot of C sharp a lot of java what was the source of the skepticism around object-oriented programming in these types of language is Java and C sharp
 I think part of the problem is so some of the things that I think closure sort of picks and chooses which parts of Ooo carries on and so the idea of polymorphism of having sort of conditional Behavior based on some aspect of your data is a good one and one that existing closure in a couple of interesting ways but the aspects of Ohio that rich was less enthused about war encapsulation and concrete inheritance so those two things are are things you will not find him enclosure and lead to things together try to bundles this notion of usually you're storing your data in fields and then your encapsulating that inside of a class
 and protecting it and then providing access to that through through methods or some sort of accessors so there's a bunch of problems with that mostly speak from like a Java perspective because I have a long job at background before I came to closure so that's what I'm most familiar with but I think most of these things also translate to some degree to other things like C plus plus it's you sharpen at Ruby things like that to the problem with fields in the in the snow snow fields is like an in job at least the those feels don't come with any sort of protection built-in so a lot of the encapsulation evolved is basically giving you hooks to allow you to
 at to add safety around access to field data that otherwise we would just access the fields directly but that's not typically What's Done in Java typically go through exams or get her method make is the opportunity to make a field you know of synchronized or something like that is that so it takes to the opposite approach of instead of building things around these mutable feels that can change in place instead we build up data and that data is a mutable certified beautiful values he start with immutable pieces at the bottom things like numbers and beans and strings at strings are immutable in every language but most modern languages those are mutable as well that's includes Java and then how do you sort of start to compose those and in a Java you use you know an arraylist hashmap or something like that
 and that as soon as you do that you didn't have this mutable object that's wrapped around your your immutable values sew-in closure we have persistent collections Love Doctors sets lists and maps and those core collections are all immutable which means that you can treat a vector of you know of other values as an immutable value and pass it around and it's it's starts life and continues its life entire existence as an immutable thread-safe thing so you don't need to protect access to it because it is inherently safe to pass it around and you never have that copy of her things like to do things like that
 so you're talking now about closures encouragement of immutability and if you double data structures and this ties into the fact that closure is a functional programming language why are immutable data structures so useful for functional programming
 well I left like I said one of the biggest benefits is that there are inherently tredsafe so that eliminates the whole class of of really nasty and hard problems with said of sharing data across threats that you have to deal with in languages that are based on certain mutable fields and locks things like that to you you never do any sort of flocking type semantics and enclosure really and so you can just very safely pass around your data cross threads not care about any of that stuff functional programming with respect to that generally things are happiest enclosure when you your program is primarily a beautiful values which most things are by default and pure functions that translate from one vehicle value to another vehicle value you can write you know very large percentage of your programs
 and that's that makes them easy to test that makes them easy to reason about because you know that a function will always produce the same output if given the same input and those are both great things since we aren't mutating our data structures does that mean that were copying them on a regular basis if you go back and look at like the commit history foreclosure you'll see that there's just there are a couple of core areas that were the first things that rich worked on one of those is the persistent Collections and the trick with persistent collections is that you want to use what's called structural sharing so as you modify sort of in there quotes a an immutable persistent collection you create a new collection but because the old one is immutable you can share large portions of it state that means that you can efficiently create a new data structure
 because you only have to create a little bit of extra structure that reuses a lot of deal structure that sort of the simple sway think about this if you think about a linked list linked-list is a persistent data structure and has all of the same properties if you have an existing linked list and you want to add a new element at the beginning you can do that you just create a new cell and point to the old linked list and so that allows you to share 100% of the old one and just add on a new element at the beginning copying
 that is not so the when you look at in particular factors and enclosure sets are really based on the map implementation I'm so really the two the two different implementations that are important early factors of Max and they're both based on the sort of tree structure internally and so the notion is that when you for example add an element into a vector at the end of a vector that you might really be able to reuse most of the existing tree that's representing the old doctor and then sort of add a new route on top or New Path on the side or if you modify an existing things you might be able to share sub trees on either side but just copy the path in the middle and modify just the portions have changed
 okay it's so if I am using these data structures in clojure do I need to be explicit about how I'm copying data structures or does this typically get taken care of under the hood for me I you don't need to hear it also I mean you can just pretend that it's a collection that has functions that operate on it and so the it has a few of the vector than you have functions like conch which is short for conjoined just needs to add a new element where it's efficient which four vectors is at the end or she's going to map you have a function called assos which is short for associate and so that associate Sanu key-value pair into the map but then they give you back the new map and so all you do is just a joke a function of the map and get back into map
 how do these aspects of clojure data management change the garbage collection story foreclosure
 well it it it it requires a garbage collector so that's an important part because you are going to be linked structures in memory right and overtime people are going to stop you know stop referencing some or all of a data structure but that point did you see has to notice and and clean those up fortunately the jvm is had probably more thousands of person years of you no effort into it any other platform on the on the planet and so there's there's a ton of work gun into that to make that good and fast and tunable and heading to work in a right wide variety of conditions not that it's perfect you know if you noticed the garbage collectors at all there's all sorts of cases that don't work for you right when you write a garbage collector for a language that's built on top of the jvm is that mean you have
 Fork the garbage collector in and write a new one or how exactly does that work no not at all so I mean that's the benefit of a building on top of the platform with as many features and stability is the jvm is that you get that for free so the way that closure works is the weight Java works is that you take Java source code which is compiled by the Java compiler into Java bytecode or jvm bytecode which is then run on the Java virtual machines is really two layers the Java source and then there's also the jvm bytecode and see what color does is it it takes closure source code and compiles it directly to jvm bytecode and then so once you've done that then you're you're doing exactly the same thing with Java compiler does and you get that for free basically when you construct objects in the jvm once they're no longer used and they're available for garbage collection so there's nothing special that needs to be done there
 okay so I want to talk a little bit more about writing code enclosure at one premise of closure is that as you said we can build a substantial portion of our programs simply using these simple data structures like maps and lists and vectors and so this should be an idiomatic part of the language because it will reduce the size and complexity of our programs how does the language encourage using these fundamental data structures rather than the I think of java and job I'm always making new data structures to do my new functionality
 well I mean it's just really what how all closure code is written I mean there is a closure sort of collection model and I've written a lengthy post on this on my blog at inside closure. Org I think it's actually is the last thing I wrote they're so pissed but looking for it that's easy to find but closer does actually have a really nice set of collection interfaces in Java under the hood and then the closure collections are implemented in terms of those interfaces and then most things enclosure are really written in terms of those disorder collection traits things like whether it's sequential whether it's reversible whether it's sorted that sort of thing so it is actually possible to write your own closure Collections and that do customized things and have them and they're really treated as first class collections by closure if you do that
 and that's a really that's at a more of an intermediate to advanced level usage you can certainly right many applications without ever meeting to do that but it can be a useful tool to pull out of the toolbox as it turns out I mean you really those are really Decor collections Lissette Vector map are really cover you to a great degree and then clear it does actually also have sorted sat sorted maps and a few other things that are used little bit less frequently in there some libraries that people use for for some additional things but I'm really combinations of those can really get you pretty far
 sure and it to talking at a lower level could you give us an overview of the closure type system and explain what makes closures type system unique the sort of Primitives that you work with any language are strings obviously and characters boolean's then you have the number support is pretty involved more involved than it's worth going into your butt and there is sort of a complicated story there because it is built on top of java and the idea with closure is to be able to achieve job a little performance and so the job of a fixed Point fixed Precision types are sort of used by default so you're you're going to be like Java you know Java Ensign Longs and doubles and things like that and so but with that said closure also prefer
 cars that you sort of blur over some of the details of those things that you focus really on a fixed position integers arbitrary Precision integers fixed position floats and and arbitrary Precision floats in really treat those the sort of the four main categories are there are some extension libraries that give you a more in-depth numeric Tower and and different things like that and then we have symbols and so symbols are just words usually they look like words and their they can be pretty broad. They could be pretty Broad in terms of what they include much broader than what you see in like a Java method name or something like that and symbols are really uses names there's things that refer to other things and so you might have something that is plus plus is a symbol that you would see in your code and it refers to the plus function or you might see you no closure. Cor that's a symbol that refers to a namespace and so
 symbols are used to name thanks things that you're going to look up and then we also have keywords key words start with a colon and then ARF look like symbols otherwise they're typically words and things like that key words are a little different in that they are effectively intern so they basically always refer to they always evaluate to themselves and that means that different parts of the code can use the same thing and because they're sort of intern for performance most equality checks really turn into identity checks and so they're very fast for that sort of comparison and because of that they're usually used to define constants or a standard keys and a map if you want to represent some some some sort of information entity a person or company or whatever you have in your domain you will typically use either a map or a record with keywords as keys and because those are sort of standard
 some things that are used across the program there we use keywords for that okay I'd like to walk through the evaluation of a closure program so we start with a file that has some written closure code we the first step of evaluating and eventually getting that to running code is we take that file and pass it to a reader what is the purpose of a reader is to turn a string which is closer code or really things that look like loader code in to close your data structures and so this is where we get into lists notion of treating code as data and so the first if the reader step is really involved for taking a string and turning it into close your data so when you see so closure being a list all expressions are represented with parentheses around it I'll sort of in vacations
 represented with parentheses where the first element in the list is the function position so you can have some things about us to a function there and then after subsequently you're going to have all the arguments that function when you read an expression like that so if you have parentheses + 1/2 parentheses in parentheses eat that's going to be read as a list and so it's going to be a list that contains the symbol a number at a number so that's sort of the syntax part of it right at that point nothing has been evaluated or anything like that and then the next step is really to go through compilation and sew a closure doesn't have an interpreter it's all all closure code is always compiled and so the compiler is going to it's going to take that a close your data structure and convert it into a bike code and that's going to generate a class and those classes are going to be loaded dynamically in the jvm classloader
 and then they're going to be invoked and lots of details about the general process code for Midas or is there a closure bytecode format or is it just Java bytecode it's just the jvm bytecode okay. It and then the other really important stuff that that we left out there is macro expansion and so one of the big features of list is always been macros and culture has macros as well and that deal with macros is that when you treat your code as data you can apply all of the transformation functions you already have in the language to transform the input code into some different output coat and so after a thing has been read at the point when we go to evaluate it at that point if we discovered that the thing in function position is a macro instead of
 piling it we can actually go off in run the macro first and so when you invoke a Mac or you give it literal code as data so you give it a list containing a function symbol representing a function man the arguments to it then there's a bunch of facilities for you know concisely stating how we should transform at code into some other code and you can return return that to the compiler so you can think of macros is a way to as sort of a user-provided compiler plug-in every macros a little doing the job of a compiler really in terms of taking code when transferring to get into other coat and that's what gives list enclosure the sort of dynamic and feel in the flexibility and that's what it when people talk about the power of less than things like that that's this is one aspect of it
 right and you know you said this a couple times dead in lisp and adopted by closure there's the ethos of code is data what does that mean what does it mean that code is data well it's exactly what I mean is that what I just said I was in forever and terms of macro expansion is that I can treat my code that I write the initial code that I write my not actually it's not it's often not going to be the actual code that's compiled by the compiler and so that allows me to do short of metaprogramming right I can I can write my own control structure that says like if I want if to work differently than it normally does I can write my own control structure and the macro can translate that into an issue or whatever else whatever sort of larger structure I wanted to let you know I actually want it to happen she means that that source code that you're reading is not technically closure right it's things
 it's things that are enclosure form and they could theoretically be closer but they don't have to be evaluated Bowl in the form that they're stored in the source file you can take that and have you might have one short expression that expands into something that defines many many bars instead many functions based on that so you can create your you know you can create say I want to be able to create a software component or something like that I'll create my own Syntax for it which is in parentheses and it looks like code but all of the things inside of it that you can have any structure at once inside of it and then a macro can turn that into whatever you know simple or complex structure that wants to win that her extension is run up to the problem kind of CID composition
 what are the key differences actually with list is that so list has the ability to create what are called reader macro so you can you can sort of extend what kinds of things can be read by the reader you can preserve plug into the reader itself enclosure very intentionally doesn't have that because the one of the problems you can get into is that someone else might not be able to read your code because they don't have your special reader plug-in and so closure Rich made a decision a long time ago that that he didn't want that to happen so that we don't have rear for your Macros we have some other things that take cover some of the same yusuke system
 wealthfront is an automated investing services that saves you time as an engineer your time is valuable if you want to invest but you don't want to spend significant time evaluating your portfolio and allocating assets take a look at wealthfront go to wealthfront.com se daily to open an account today and get a special offer for software engineering daily listeners $15,000 manage for free when you open your account with traditional Investment Services there are many humans in the loop that are doing things that well front automate away when you pay the commission's an account fees of these traditional Investment Services you're paying for work that could be done by a computer so don't pay commissions and account fees maximize your gains with wealthfront set-it-and-forget-it investment automation check out well front.com SE daily it would support software engineering daily and it would introduce you to the world of automated investing
 wealthfront.com SE daily thanks to wealthfront for being a continue to sponsor of the show now let's get on with the show
 okay what's shifting gears completely and talk about concurrency so before we get into how closure handles concurrency specifically what are the typical challenges that we deal with concurrent program that can set us up for a conversation of how closure solve those problems
 yeah I'm happy I break concurrency as far as we see it in in most modern programs into a few different kinds of problems one is sort of like being able to push something into a background threat like I want to do this thing but I don't actually need the result for it right now and so I just want that you know I'm going to go call an external web service and at some point later I'm going to need the answer but I don't need it right now in sound do the sort of non-blocking background work so that's one kind of a task another is I want to take sort of a stream of work items and I want to have all my coursework on processing those items
 and so I call that lady q's and workers things like that or in Java executorservice are sort of design for this problem so that's it and then another kind of sort of fine-grained date of parallelism anything that is commonly described like as embarrassingly parallel like I want to I want to execute a function for every pixel on the screen you know that sort of thing generating metal rock images or whatever and so that's it that's a similar problem in some ways to the work to the workers and Qs but having a single queue has scalability issues in terms of wanting to do all those things that don't actually depend on each other two at the same you know if when your Computing a different function for everything on the screen you don't need to go through a single cue to do that you really want some more efficient way to manage all of that parallel work and so they tend to have a different shape to the to the solution
 how does Java tend to deal with these concurrency problems in and what kind of problems does does jobs approach create
 I will try has excellent set of tools for dealing with mean currency so so I have no I have no knocks against against job in the disregard and I've done a lot of java concurrency programming in and it has a amazing set of tools in the the people that are involved with that and it's ugly and and Brian Katz and all those guys are doing a phenomenal work and so negative about any of that stuff but they have tools for concurrent data structures so things like the current hashmap and that's a that's a great building tool on something we use inside closure in the implementation of closure they have the ability to create threads and to do things like wait for Treads and and coordinated cross threads again that's all really useful stuff and things you can use directly from closure
 you know how does how does clojure manage concurrency and why does that fundamentally contrast with how Java manages concurrency
 I think actually closer doesn't contrast a lot what job in terms of have bandages concurrency I think in contrast a lot in terms of how it deals with State and so I'll refrain more question that way and things like that earlier but the mental mentally different approach to to stay in general in in Java you typically are working from mutable objects that hold your state and they have all these problems around locking and and shared access to those things and so the first level of it is you know and Ryan guests from who's the Java language architect his is famously said that a lot of the problems with concurrency you boil down to Shared medical State and the solution that is to not share or not mutate and so in terms of mutating using closure
 beautiful data salts one chunk of the problem like there's a whole bunch of common problems that are solved by just using a beautiful value start with but you do really need to share State like most programs need some state that needs to be shared across the lifetime of the program that you're going to maintain an update and multiple people need to have references so they can see the current value of that thing and just passing a beautiful Valley around is not sufficient for that need to have independent entities that can coordinate over some shared piece of state and so closure has a series of reference and Eddie's that reference types that are that are used to provide that and all of those share certain things which is all of them can be read at any time without blocking and so that means that reads are always free
 or almost free if they're uncontended reason the jvm then they probably are pretty they're very cheap probably all those things take it approached where
 identity is separate from state so the thing that you share is really an identity and if you want the state at that identity you will go ask it and say I'm going to go I want your current the current value of your state and it when you want to update it you pass something not a new value but a function that will produce a new value based on the old value and the key difference there is that if two different threads send a function at the same time they're going to be applied in one or the other of concurrency you don't know which is going to happen but because you're applying a pure function to an immutable value to produce a new value you're never going to produce an invalid value in there there is just a series of points that are new invalid immutable values and there's a peer functions being applied to take you from interview in utero if I didn't meet over by you so you can never see bad state or are partially Define state or anything like that
 that's just sort of not available in these types of of mutable reference types are vars refs and agents could you explain what these three different types do yeah you actually left out probably the most important one which is Adams the reference types
 animals start with Adam actually because it's because it's the most commonly used for the singer from and so an atom is if you're familiar with Java it's exactly the same thing as one of the atomic types in Java util concurrent Atomic said something like an atomic energy or Atomic reference. You're one of those kind of things it's a 8 holes a single value and she have the ability to update that value in the way that it's done enclosure is working to wear in a create an atom and then you're going to your going to call it with a function that can update it to a new version of the atom and when and it really does this through basically a spin lock and so if it's uncontended you're going to immediately succeed in value if it is contented that you're going to get in line between behind whatever other functions are out there and you'll just keep trying to modify the value over and over again
 turns out this all through through the jvm and all of the great engineering below that this turns out to be a really fast operation in and getting sort of a faster over time as well and so that's actually that the primary means is turned out to be the primary way that I put your programmer sure state is to typically have a some sort of a compound value usually a map that holds the state of our application and then pass a function to it that says modify that state and and give me a new version of my state of Ohio so that's a that's a beautiful thing to test and it's easy to reason about understand
 the problem with it is that you can't coordinate two of them so there's no safe way to coordinate two of them together and that's where once you need to do that you're going to have to introduce what are known as refs and so Russ allow you to coordinate a global time line across stateful entities and that's done through a software transaction number system and it says as long band it was like one of the reserve calling cards foreclosure in the early days and it works great but interesting ly it's surprising how much you can get done will Adamson so I think for me one of the big lessons over time has been that atoms actually get you what you need 90% of the time and then you reach for rafts in the STM you don't maybe 10% of the time no way that Russ work is you define a transactional boundary and you to find the actions that should happen against rafts in that transactional boundary and then the STM is worse
 also for applying that transaction and because you're working Shirley with immutable immutable values not start of the value stuff is so it's a really important assumption for so many parts of closure you can sort of speculative Lee apply functions to those wraps and know that at the end of it if somebody else happened to modify one of those wraps in the meantime I can just throw away my changes because the date is immutable so the original value still exist I still kept to handle to them and I can just throw away my service specula changes and fall back to the original ones and then retry my transaction so it sort of makes these that sort of transaction recovery a lot easier
 awesome okay so let's let's talk about other jvm functional language is so there are these other languages like Scala and groovy that have been built on the jvm why would I choose closure over the other dynamic jvm-languages
 so I tell you Scott was not a dynamic language and language and so so I've done working groovy installing the past and and I have nothing I have nothing bad to say about them they always languages are doing interesting things and and making different choices in terms of how they provide things to two users in for me what drew me into closure was really the fact that everything enclosure is really designed around creating tools for simpler coat like from having you know I've been doing programming for about 20 years professionally and when I find closure I was at a point where I was really kind of fed up with it I just done so much for coming and I was so tired of fighting to sort of the incidental complexity of everything around sort of modern 00 programming
 that I was about ready to like just give up and change careers or become a manager or to something else and so so many the choices and closure are about avoiding things that sort of cause incident all complexity in entanglement between parts of a features of the program and things like that and I think that it's really continuing to find new ways to do that and then like to the big new feature that we've been working on this year is called closures fact which is this tool for specifying the structure of data and functions and that's really it's it's a it's a different direction than types and it's a different way to provide some of the things that people want from types but we believe in a way that makes different trade-offs
 more important for foremost programmers
 oh yeah so this is the big thing that we worked on and it really lets you sort of this bunch of key should have premises baked into it there's I could probably do a whole show just talking about closures back but it's the idea is that you want to build up a specification for your data and you want to at the bottom base that on predicates so we don't want to build a new language that describes types or custom vocabulary for those who want to use existing functions products in our language so either things that are built into the closure core or functions that you already have lying around that might tell you that you know is this account overdrawn like that might be a function and you can build a spec that describes your data based on that so it has that serve the base and then it has the ability to a number of ways to combine protective Stacks in compose them into larger and more assertive compound specks in different ways
 and then you get a bunch of things for for free when you do that so you get you those sorts of things get it automatically attach to documentation both sort of in your in your runtime environment and also any sort of whatever you the documentation you generate you get the ability all of the specs actually are designed to produce to act as generators I'm so they can produce example data that is conforming to the SPAC until you can generate examples if she stuck a function you can not only generate examples you can run a function called checks that will generate a things basically examples that are valid arguments based on your specs invoke your function
 you ever done a spec for your return type and it will verify that your return type the return that comes out of your function is valid and then there's another Speck called that we call the offense back or the funds back which actually allows you to relate the incoming arguments to the return value and so you can write very expressive specs that like for example if you have an index out function that takes a string and a search string and it's going to return like the index that it matched on or something like that you can write a function spec that says that school so they are expect might say I'm taking a string a string the returns back might say I'm getting back an integer and their funds back might say I want to verify that my integer is in the range between 0 and the count of the incoming Source string
 and that's something that's much more stress than you can say in most types of stuff there are some you know like there's like a dress and other things that are trying to get this level of extra City and take systems but and you're doing all that just with normal closure coat so it's all sort of in the same language that you're writing the rest of your program in
 let's talk some about the interoperability story so if I'm an engineer at a Java shop all the code at my company is written in Java and I want to start writing some closure code is there any diplomacy that I'm going to need to do with the rest of the team or what degree is my closure code can be interoperable with other people's code that's a good question so there's really to serve directions there in terms of using Java stuff from closure or using close your stuff from java right and so from the first perspective if you were like writing new closure coat that's cool that you want to use existing part of your existing java-based that's generally really really easy most people find that it's actually easier to call Java API is enclosure than it is to call it in Java is really nice and it's all you could do it at the Ruffles
 can do it sort of you can. I should have been an awfully be sort of interacting with the Java API or whatever at the raffle as you develop and that's a joyful things compared to testing in debugging most Java programs for mice trance access to every Java Library out there so that's a huge leverate set alive or he's obviously most things work really really well in terms of how they look and how they interact with them enclosure there are certain restrictions because Java libraries you know are going to use create beautiful objects and things like that so you have to be worried about those places where things assume any of the immutability & Java mean enclosure but you're using Something Beautiful from java there are some things like that you have to be aware of but in general it's pretty pretty nice and joyful thing to access Java from closer coming from the other direction it really
 what time does little bit there's a bunch of different techniques you can use there is a a Java API foreclosure that lets you get access to bars which hold functions in enclosure and a joke them and and load code and do things like that and so there is that API what I found the best is to Define an interface that serve separate the closure part of the code and find that in Java and write your normal interface Richard doc strings generator do all that stuff then have your closure code basically Implement that interface or interfaces interested of providing implementation to an API and I found that works really really well in a lot of today's infrastructure I mean people are Building microservices architecture is naps and things like that and we see lots and lots of people who are in companies where they have a micro in some sort of microservice architecture and they have
 services in a in many languages and they operate basically by how they put messages on a bus or whatever until you're not actually calling directly into other languages right yeah you have some kind of message passing layer and yours just sending Json between different services so that's like language into an independent
 what about like mental leaps are there any mental leap that are traditional Java programmer would need to make in order to be effective enclosure
 sexy I think like one of the things people expect to be hard as the immutable collection aspect in practice I find that is almost never a problem like it's just really really is just not an issue for most people I think definitely the some people are turned off by the parens the way closure looks most programs that work enclosure find that they stopped really seeing them or caring about them after a few weeks or a month and so if that feels unusual they get over that pretty rapidly that's not true for everybody some people it is a hurdle
 and I think laziness is one aspect we haven't really talked about closure sequences but I'm closer has a sort of unifying model for accessing accessing data structures called sequences sequences are really sort of a logical list of straction basically being able to treat any data structure as if it were a logical list and sort of Traverse sequentially through the list one of the cool things about sequences that they're all so beautiful and can be passed around and thread Safeway and you can kind of blur the line between Collections and sequences pretty seamlessly but they're also lazy and so are can be lazy and so you see a lot of times that it's a it's a common hurdle to do something that it write a program that is so lazy that it doesn't actually do anything so he forget to actually realize a lazy Secrets at the end or whatever that actually is required to produce all the day
 so that kind of thing comes up sometimes the first 6 months for sure
 so I had a listener ask why does there seem to be a lack of design patterns enclosure versus a language like Java and I want to say that about you judgement on the closure I don't think design patterns are necessarily a good or a bad thing but this lesson or seems to think that there is a lack of design patterns and closure but I think there's two ways to take that and so I think there's a sort of a good way to say all those design patterns are papering over flaws in the language and it's just better that way whatever I don't think that's that I think there's maybe maybe some small truth there but I do think there are some design patterns that are working around in flexibility of of different calling patterns and things like that and Java but really I think along that lines functions really get you out of so many
 you can it's the sort of ultimate abstraction that if you want some variable Behavior you just pass a function in and you can choose to fast different Behavior later on and so it's it's not that the I think that things like that you know the gang of four design patterns do describe problems that we run into it real code and that's true of it regardless of language that she said in that you know design-patterns Art of Steal This sort of they're going to show you a structure that's a bigger structure that's used to sort of satisfy that pattern and a general in functional programming I think most of those needs are actually handled pretty and flea by functions but it's actually kind of interesting another way you can you can look this question is are there other problems that show up and functional programming that have their own sort of design pattern feel to them and I think that's definitely true
 I think there are certain sort of application structural problems that have you know Common Solutions across across different FP code bases things like that so I don't I don't think it's and I think that we have not we is a functional programmers we if not doing a great job and serve catalog in your talking about those
 so there are some talks out there in particular by store at Sierra at where he looks at different design patterns in enclosure so I've ever had nose
 you recently wrote a book called closure applied could you talk briefly about the goals of the book and what maybe what we have not covered in this conversation that you do you cover in the book
 yeah right that would have been bankrupt and and so it was a it was a 50-50 efforts are make sure to mention him on that too I wasn't just my book so our goal with that really was that when you look around the closure service-learning landscape there are now I think really fantastic getting started with closure materials available both in book form and on online tutorial form and all those kinds of things so and exercises like all those things exist and I have good answers for a shoot someone ask me about any of those things I have good answers for putting in a different directions simile there are some some smaller number but excellent sort of more advanced or comprehensive resources things like the joy of closure weave what we thought was really missing that we were at the whole we were trying to plug was really sort of
 you know I forgot my who's who's worked enclosure for 3 months or 6 months or something like that they do understand the language they understand the syntax they're having trouble actually structuring real applications and so that's that was the Gap that we wanted to sort of fit into how can we start and assume you know the syntax pretty much and some of the core library but you're not sure how to best use it and how to structure your applications hence the name
 exactly close your butt right let's talk a little bit strange Loop which is a conference that you are the founder of what are the goals of strange look like how does strange Loop differ from other Shopper kopertis could just my personal space I watch a lot of the strain to the videos and they're very entertaining and they are someone different than other conferences but I can't exactly put my finger on what makes them different is a conference has started 2009 and it's in St Louis which is where I live and my idea for it was really that I wanted to like in retrospect if I not come on the name that I did Stranger Than which I'm really happy with and I'm going to keep but if I not come up on that like another really good name would be something like diamond razor edges or something like that cuz I really wanted to explore places where that are create a place for people from
 different Computing environments could serve overlap and like to serve notion of like we're interesting things happen in the environment is at the edges of ecosystems where things overlap that's for you get speciation and all sorts of hybridization and things like that that was what I was always interested in sort of fermenting if you were if I use that word descriptive couldn't put my finger on it and I think a lot of the conversations end up being about distributed systems and I find that distribution so interesting cuz that's being tackled in you know and every domain from front-end to back-end and in all these different ways do have interesting parallels like you look at how react JS handles something and it tends to look some somewhat similar to baby how Kafka handles some
 and I find the Distribution Systems is maybe that the thing that is tying these things together
 yeah it's funny I like last year's was definitely a heavy on this to stripped it systems and in some degree like it's funny how like every year I find there are
 yo I walk out of the conference at the end feeling like there was some sort of theme that I kept hearing about all through the conference and I'm the you know sort of the lead person using the talks and and putting the other program and I don't know what that seem is before I get to the conference even though I know what all the speakers are and all the talks are it's not obvious to me what that seemed always is and so it's really interesting to me how it become sort of emergent their Serta this like Dobby a topic that's going on at sort of them fax all the socks or many of the same you know talks and I come sometimes explicit sometimes it's it's just the sort of background fuzz of what's going on right now so like some of yours it like it's been some real really about functional programming about you no static versus Dynamic types or no sequel or whatever so that's kind of changed over the years so that was definitely the system area was
 are there a lot of tire fire pictures last year okay this is been a great conversation I am really happy you came on to have a conversation about closure yeah my pleasure
 thanks to sinfonico for sponsoring software engineering daily symphonic is a custom engineering shop where senior Engineers tackled big Tech challenges while learning from each other check it out its symphony.com SE daily that's s y m p h o n o. Com SE daily thanks again siphano
